<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>微软在移动优先、云优先的世界中处于什么位置？</title>
    <url>/16583.html</url>
    <content><![CDATA[<p>微软继续推广移动优先、云优先的游戏计划。这包括影响他们全面工作的变化。今天在西雅图举行的 Microsoft Build 大会上，微软提到了一些关于他们在云和移动计划方面的立场的统计数据。</p>
<p>Microsoft Windows 10 月度活跃用户<br>微软世界的核心是他们的核心操作系统，Windows 10。Windows 10 月活跃用户达到 5 亿</p>
<p>商业办公 365 月活跃用户<br>Microsoft Office 365 现在拥有 1 亿月度商业用户。由于 Office 已成为许多企业用户的核心生产力平台，Microsoft 正在为 Office 开发人员提供更多机会。这包括他们在上周的一次教育会议上谈到的微软团队的公告，开发人员可以访问该公告以添加扩展来执行诸如添加通知、扩展和可操作消息之类的操作。开发人员还可以使用新的 Microsoft Graph API 来利用 Microsoft 内部的数据和智能。最后，Microsoft 正在为 Azure 上的生产应用程序提供一种方式，现在可以向数以亿计的 ISV 活跃办公用户公开。</p>
<span id="more"></span>
<p>Cortana 月度活跃用户<br>Cortana 1.41 亿活跃用户。虽然这是一个很大的数字，但它包括使用任何类型的 Cortana 交互（包括语音）的人。</p>
<p>Azure Active Directory 中的组织12<br>Azure Active Directory 在组织内继续增长。现在使用 Azure Active Directory 的组织已增加到 1200 万个。</p>
<p>使用 Microsoft 云的财富 500 强公司<br>虽然微软云可能不是领导者，但值得注意的是，财富 500 强公司正在使用微软云。使用微软云的财富 500 强公司的百分比现在超过 90%。</p>
<p>面向开发人员的认知服务<br>一个很大的嗡嗡声是认知服务。随着数据和智能的增长，认知服务现在可以大大增加开发人员的能力。微软声称是认知服务领域最广泛的产品之一，为开发人员提供了 29 种不同的服务。开发人员可以利用的这些服务包括视觉、语音、语言、搜索等。添加的一些新服务包括必应自定义搜索、自定义决策服务、视频索引器、演示翻译和自定义视觉服务。</p>
<p>将它们加在一起<br>这些数字只是触及了微软正在发生的事情的表面。寻找来自 Microsoft Build 的其他一些新闻的报道。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>微软</tag>
      </tags>
  </entry>
  <entry>
    <title>代码改变世界</title>
    <url>/1504.html</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![img](/pic/img20220727.png)</span><br><span class="line">sudo apt-get update</span><br><span class="line">./RNU-ME.sh</span><br></pre></td></tr></table></figure>


<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> attributes = [</span><br><span class="line">  <span class="string">&#x27;autocomplete=&quot;off&quot;&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;autocorrect=&quot;off&quot;&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;autocapitalize=&quot;off&quot;&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;spellcheck=&quot;false&quot;&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;contenteditable=&quot;true&quot;&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> attributesStr = attributes.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="regexp">/&lt;figure class=&quot;highlight ([a-zA-Z]+)&quot;&gt;.*?&lt;\/figure&gt;/</span>.<span class="title function_">test</span>(data.<span class="property">content</span>)) &#123;</span><br><span class="line">    data.<span class="property">content</span> = data.<span class="property">content</span>.<span class="title function_">replace</span>(<span class="regexp">/&lt;figure class=&quot;highlight ([a-zA-Z]+)&quot;&gt;.*?&lt;\/figure&gt;/</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> language = <span class="title class_">RegExp</span>.<span class="property">$1</span> || <span class="string">&#x27;plain&#x27;</span></span><br><span class="line">      <span class="keyword">var</span> lastMatch = <span class="title class_">RegExp</span>.<span class="property">lastMatch</span></span><br><span class="line">      lastMatch = lastMatch.<span class="title function_">replace</span>(<span class="regexp">/&lt;figure class=&quot;highlight /</span>, <span class="string">&#x27;&lt;figure class=&quot;iseeu highlight /&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;&lt;div class=&quot;highlight-wrap&quot;&#x27;</span> + attributesStr + <span class="string">&#x27;data-rel=&quot;&#x27;</span> + language.<span class="title function_">toUpperCase</span>() + <span class="string">&#x27;&quot;&gt;&#x27;</span> + lastMatch + <span class="string">&#x27;&lt;/div&gt;&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>







<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>Php</tag>
      </tags>
  </entry>
  <entry>
    <title>执行sudo apt-get update时，无法获得锁 /var/lib/apt/lists/lock</title>
    <url>/59101.html</url>
    <content><![CDATA[<p>百度到的方法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo kill 2224</span><br></pre></td></tr></table></figure>
<p>可是我发现不行，然后又找到其他方法，也不行。<br>后来发现是自己不小心虚拟机多开了几个，<br>干脆把电脑重启，才解决了这个问题。<br>只把虚拟机重启是不行的。</p>
<p>原因：刚装好的Ubantu系统，内部缺少很多软件源，这时，系统会自动启动软件源更新进程“apt-get”，并且它会一直存活。由于它在运行时，会占用软件源更新时的系统锁（以下称“系统更新锁”，此锁文件在“&#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;”目录下），而当有新的apt-get进程生成时，就会因为得不到系统更新锁而出现”E: 无法获得锁 &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;lock - open (11: Resource temporarily unavailable)”错误提示！因此，我们只要将原先的apt-get进程杀死，从新激活新的apt-get进程，就可以让新立德软件管理器正常工作了！</p>
<span id="more"></span>
<p>问题描述<br>在执行sudo apt-get update时，遇到如下问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E: 无法获得锁 /var/lib/apt/lists/lock。锁正由进程 2224（apt-get）持有</span><br><span class="line">N: 请注意，直接移除锁文件不一定是合适的解决方案，且可能损坏您的系统。</span><br><span class="line">E: 无法对目录 /var/lib/apt/lists/ 加锁</span><br></pre></td></tr></table></figure>
<p>根据提示，是因为进程2224占用了这个锁，linux系统一次只允许一个进程执行apt-get，因此只需要把这个进程杀掉就可以：<br>解决方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo kill 2224</span><br></pre></td></tr></table></figure>
<p>问题解决！</p>
<h3 id="解决E-Could-not-get-lock-x2F-var-x2F-lib-x2F-apt-x2F-lists-x2F-lock-open-11-Resource-temporarily-unavailable"><a href="#解决E-Could-not-get-lock-x2F-var-x2F-lib-x2F-apt-x2F-lists-x2F-lock-open-11-Resource-temporarily-unavailable" class="headerlink" title="解决E:Could not get lock &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;lock - open (11: Resource temporarily unavailable)"></a>解决E:Could not get lock &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;lock - open (11: Resource temporarily unavailable)</h3><p>出现这个问题的原因可能是有另外一个程序正在运行，导致资源被锁不可用。而导致资源被锁的原因，可能是上次安装时没正常完成，而导致出现此状况。</p>
<p>解决方法：输入以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo rm /var/cache/apt/archives/lock</span><br><span class="line">sudo rm /var/lib/dpkg/lock</span><br></pre></td></tr></table></figure>
<p>之后再安装想装的包，即可解决</p>
<p>今天玩ubuntu的时候，在弄更新源的时候，突然出现以下错误：<br>[1]+ Stopped                 sudo apt-get update<br>haiquan@haiquan-desktop:~$ sudo apt-get update<br>E: Could not get lock &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;lock - open (11: Resource temporarily unavailable)<br>E: Unable to lock the list directory<br>开始以为是权限不够，就是用 sudo apt-get update,发现还是报错，问题没有解决。于是上网搜索了一下，答案如下：<br>问题应该是之前那个更新被强制取消的问题，进程仍然还在。用这个命令查看一下：<br>ps -e | grep apt<br>显示结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6362 ? 00:00:00 apt</span><br><span class="line">6934 ? 00:00:00 apt-get</span><br><span class="line">7368 ? 00:00:00 synaptic</span><br></pre></td></tr></table></figure>
<p>然后就执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo killall apt</span><br><span class="line">sudo killall apt-get</span><br><span class="line">sudo killall synaptic</span><br></pre></td></tr></table></figure>
<p>再次在终端里查看ps -e | grep apt 没有任何结果了</p>
<p>继续执行sudo apt-get update</p>
<p>OK！</p>
<p>原因：刚装好的Ubantu系统，内部缺少很多软件源，这时，系统会自动启动软件源更新进程“apt-get”，并且它会一直存活。由于它在运行时，会占用软件源更新时的系统锁（以下称“系统更新锁”，此锁文件在“&#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;”目录下），而当有新的apt-get进程生成时，就会因为得不到系统更新锁而出现”E: 无法获得锁 &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;lock - open (11: Resource temporarily unavailable)”错误提示！因此，我们只要将原先的apt-get进程杀死，从新激活新的apt-get进程，就可以让新立德软件管理器正常工作了！</p>
<p>这时，你可以按一下步骤来解决：<br>1、输入以下命令：“ps -aux  &gt; temp.txt”.敲回车确定。这时会有“warning”出现，但不予理会。<br>2、输入以下命令：“grep -n apt-get temp.txt”键入回车确定。而后从命令输出中找到 apt-get 进程的PID。<br>3、输入以下命令：“sudo kill <PID>”。<br>4、完成。</p>
<p>or<br>如果提示错误:E: Could not get lock &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock - open (11 Resource temporarily unavailable)<br>输入</p>
<p>sudo rm &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;lock<br>即可</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu的系统设置不见了找回,然后更新软件源</title>
    <url>/57909.html</url>
    <content><![CDATA[<p>网上查到的方法都是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$sudo apt-get update</span><br><span class="line">$sudo apt-get install unity-control-center</span><br><span class="line">$sudo apt install gnome-control-center</span><br></pre></td></tr></table></figure>
<p>我现在遇到一个新情况，那就是我的更新源出错了。<br>我就是要找到【系统设置】换更新源，<br>现在让我直接执行update，会提示很多错误。</p>
<p>我在随便操作的时候，突然进入&#x2F;etc&#x2F;apt&#x2F;<br><img src="/pic/img20220727.png" alt="img"></p>
<p>当我双击sources.list的时候，就跳出了这个更新源的设置，<br>于是我顺便换了更新源，然后再执行那两条命令即可。</p>
<p>另外，系统设置是点屏幕右上角的开关按钮，和关机按钮在一起。</p>
<h3 id="Ubuntu-如何更新软件源-阿里源、华为源、清华源等"><a href="#Ubuntu-如何更新软件源-阿里源、华为源、清华源等" class="headerlink" title="Ubuntu 如何更新软件源(阿里源、华为源、清华源等)"></a>Ubuntu 如何更新软件源(阿里源、华为源、清华源等)</h3><p>前言<br>Ubuntu系统自带的更新源服务器在国外，下载速度一般很慢，所以更换为国内源就成为必要操作了。</p>
<span id="more"></span>
<p>一、Ubuntu 更新软件源的方法<br>Ubuntu 更新软件源的方法：<br>1、打开终端；<br>2、输入命令备份原有软件源文件；<br>3、打开sources.list文件并添加新的软件源地址；<br>4、输入命令更新系统软件源地址。</p>
<p>二、具体步骤<br>具体步骤如下：<br>1、使用快捷键【ctrl+alt+t】打开终端。<br>2、输入以下命令备份原有软件源文件。<br>cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.bak_yyyymmdd<br>3、再输入以下命令打开sources.list文件并添加新的软件源地址。<br>vim &#x2F;etc&#x2F;apt&#x2F;sources.list #打开sources.list文件</p>
<p>PS： 新安装的Ubuntu可能没有安装Vim, 用如下命令先安装Vim：<br>sudo apt-get install vim-gtk</p>
<p>在文件末尾添加新的软件源地址，常用国内源地址如下：<br>#阿里源地址<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-backports main restricted universe multiverse</p>
<p>#华为源地址<br>deb <a href="https://repo.huaweicloud.com/ubuntu/">https://repo.huaweicloud.com/ubuntu/</a> focal main restricted<br>deb <a href="https://repo.huaweicloud.com/ubuntu/">https://repo.huaweicloud.com/ubuntu/</a> focal-updates main restricted<br>deb <a href="https://repo.huaweicloud.com/ubuntu/">https://repo.huaweicloud.com/ubuntu/</a> focal universe<br>deb <a href="https://repo.huaweicloud.com/ubuntu/">https://repo.huaweicloud.com/ubuntu/</a> focal-updates universe<br>deb <a href="https://repo.huaweicloud.com/ubuntu/">https://repo.huaweicloud.com/ubuntu/</a> focal-backports main restricted universe<br>deb <a href="https://repo.huaweicloud.com/ubuntu/">https://repo.huaweicloud.com/ubuntu/</a> focal-security main restricted<br>deb <a href="https://repo.huaweicloud.com/ubuntu/">https://repo.huaweicloud.com/ubuntu/</a> focal-security universe</p>
<p>#中科大源地址<br>deb <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic main restricted universe multiverse<br>deb-src <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic main restricted universe multiverse<br>deb <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb-src <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb-src <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb-src <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb-src <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-proposed main restricted universe multiverse</p>
<p>#163源地址<br>deb <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic main restricted universe multiverse<br>deb <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb-src <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic main restricted universe multiverse<br>deb-src <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb-src <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb-src <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb-src <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic-backports main restricted universe multiverse</p>
<p>#清华源地址<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic main restricted universe multiverse<br>deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-backports main restricted universe ultiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-proposed main restricted universe ultiverse</p>
<p>4、输入命令更新系统软件源地址:<br>apt-get update<br>apt-get upgrade</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>换电脑把hexo从GitHub上克隆到本地-恢复使用操作</title>
    <url>/25333.html</url>
    <content><![CDATA[<p>先从github上克隆下来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:code8cn/code8cn.github.io.git</span><br></pre></td></tr></table></figure>
<p>然后进入目录执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>当然要已经安装好hexo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>一、配置环境<br>1.安装git（点击进入Git官网，如果嫌下载慢自行百度解决~）<br>2.Git与远程库进行SSH授权(点击查看教程Git的安装-与远程仓库GitHub配置)<br>2.安装node.js  （点击进入nodejs官网直接下载）</p>
<p>二.配置本地博客<br>1.安装hexo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>安装好后不需要初始化（hexo init）<br>2.克隆GitHub上保存的hexo网站原文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:code8cn/code8cn.github.io.git</span><br></pre></td></tr></table></figure>
<p>3.生成缺少的网站文件</p>
<p>进入克隆的目录，执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>因为上传GitHub时有.gitignore文件，所以上传到github上默认是忽略掉 node_modules等文件夹，即仓库的hexo分支并没有存储这些文件，所以需要install生成。</p>
<p>三.生成、部署（推荐）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>刚恢复本地hexo最好生成部署一下，接下来就像以前一样了。</p>
<p>参考资料1：<a href="https://www.zhihu.com/question/21193762/answer/489124966">https://www.zhihu.com/question/21193762/answer/489124966</a><br>参考资料2：<a href="https://www.jianshu.com/p/0b1fccce74e0">https://www.jianshu.com/p/0b1fccce74e0</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 安装nodejs最新版本简单方法</title>
    <url>/33390.html</url>
    <content><![CDATA[<p>···<br>sudo apt update -y<br>sudo apt install -y npm<br>sudo npm config set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a><br>sudo npm install n -g<br>sudo n stable<br>···</p>
<h3 id="ubuntu-上安装node-js-的简单方法"><a href="#ubuntu-上安装node-js-的简单方法" class="headerlink" title="ubuntu 上安装node.js 的简单方法"></a>ubuntu 上安装node.js 的简单方法</h3><p>一、安装<br>1.$ sudo apt-get install nodejs<br>2.$ sudo apt-get install npm</p>
<p>二、升级<br>    1.升级npm命令如下：</p>
<p>$ sudo npm install npm -g<br>&#x2F;usr&#x2F;local&#x2F;bin&#x2F;npm -&gt; &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;npm&#x2F;bin&#x2F;npm-cli.js<br><a href="mailto:&#110;&#x70;&#109;&#64;&#x32;&#x2e;&#x31;&#x34;&#46;&#x32;">&#110;&#x70;&#109;&#64;&#x32;&#x2e;&#x31;&#x34;&#46;&#x32;</a> &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;npm<br>2.升级node.js命令如下：<br>$ npm install –g n<br>$ n latest(升级node.js到最新版)  or $ n stable（升级node.js到最新稳定版）<br>    n后面也可以跟随版本号比如：$ n v0.10.26 或者 $ n 0.10.26</p>
<p>三、npm镜像替换为淘宝镜像</p>
<p>1.得到原本的镜像地址<br>$ npm get registry </p>
<blockquote>
<p><a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a><br>设成淘宝的<br>$ npm config set registry <a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org/</a></p>
</blockquote>
<p>2.换成原来的<br>$ npm config set registry <a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a></p>
<span id="more"></span>
<p>四、选装cnpm<br>1.说明：因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事。！来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”；<br>2.官方网址：<a href="http://npm.taobao.org;/">http://npm.taobao.org；</a><br>3.安装：命令提示符执行npm install cnpm -g –registry&#x3D;<a href="https://registry.npm.taobao.org;/">https://registry.npm.taobao.org；</a>  注意：安装完后最好查看其版本号cnpm -v或关闭命令提示符重新打开，安装完直接使用有可能会出现错误；</p>
<p>注：cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm（以下操作将以cnpm代替npm）</p>
<p>五、全局安装与本地安装<br>  npm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有-g而已，</p>
<p>   比如我们使用 npm 命令安装常用的 Node.js web框架模块 express:</p>
<p>$ npm install express          # 本地安装<br>$ npm install express -g       # 全局安装</p>
<p>六、卸载<br>1.先卸载 npm<br>  sudo npm uninstall npm -g<br>2.卸载nodejs<br>  sudo apt-get remove nodejs<br>方式二：nvm安装<br>安装<br>wget -qO- <a href="https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh">https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh</a> | bash<br>使用<br>安装成功后,需要关闭xshell，重新启动。nvm才会生效。</p>
<p>使用command -v nvm查看nvm是否安装成功</p>
<p>root@linuxidc:~# command -v nvm<br>nvm<br>查看已安装<br>通过nvm ls查看已安装的版本</p>
<p>$ nvm ls<br>            N&#x2F;A<br>node -&gt; stable (-&gt; N&#x2F;A) (default)<br>iojs -&gt; N&#x2F;A (default)<br>查看有哪些可安装<br>通过nvm ls-remote查看可使用版本</p>
<p>$ nvm ls-remote<br>        v0.1.14<br>        v0.1.15<br>        v0.1.16<br>        v0.1.17<br>        v0.1.18<br>…<br>安装nodejs<br>通过nvm install 7.8.0来安装，后面的版本号我们可以任意选择</p>
<p>root@linuxidc:~# nvm install 7.8.0<br>Downloading and installing node v6.2.0…<br>Downloading <a href="https://nodejs.org/dist/v7.8.0/node-v7.8.0-linux-x64.tar.xz">https://nodejs.org/dist/v7.8.0/node-v7.8.0-linux-x64.tar.xz</a>…<br>我们上面使用的是国外的服务器下载，很慢，耐心等待，nodejs和nvm成功安装！</p>
<h3 id="ubuntu-安装nodejs"><a href="#ubuntu-安装nodejs" class="headerlink" title="ubuntu 安装nodejs"></a>ubuntu 安装nodejs</h3><p>安装nodeJS之前，如果没有安装g++及 libssl-dev，则先要安装好，安装方法如下：</p>
<p>$ sudo apt-get install g++<br>$ sudo apt-get install libssl-dev</p>
<p>接下来，就可以下载安装nodejs了，，下面是安装步骤：</p>
<p>&#x2F;&#x2F; 下载<br>$ wget <a href="http://nodejs.org/dist/v0.10.24/node-v0.10.24.tar.gz">http://nodejs.org/dist/v0.10.24/node-v0.10.24.tar.gz</a><br>&#x2F;&#x2F; 解压：<br>$ tar -zxf node-v0.10.14.tar.gz $ cd node-v0.10.14<br>&#x2F;&#x2F; 默认安装： （默认在home目录下）<br>&#x2F;&#x2F;选择目录安装（将nodejs安装在&#x2F;usr&#x2F;local&#x2F;node目录下）<br>$ .&#x2F;configure -–prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;node<br>$ sudo make<br>$ sudo make install<br>这也是ubuntu 安装.tar.gz格式软件的方法。<br>　　1、tar -zxf　　***.tar.gz<br>　　2、cd 进入解压的目录<br>　　3、sudo .&#x2F;configure     –prefix　　&#x3D;　　&#x2F;usr&#x2F;local&#x2F;软件名 （–prefix 是软件装的目录）<br>　　4、sudo make<br>　　5、sudo make install<br>注：<br>　　1、–prefix 指定安装路径<br>　　不指定prefix，则可执行文件默认放在&#x2F;usr &#x2F;local&#x2F;bin，库文件默认放在&#x2F;usr&#x2F;local&#x2F;lib，配置文件默认放在&#x2F;usr&#x2F;local&#x2F;etc。其它的资源文件放在&#x2F;usr &#x2F;local&#x2F;share。你要卸载这个程序，要么在原来的make目录下用一次make uninstall（前提是make文件指定过uninstall）,要么去上述目录里面把相关的文件一个个手工删掉。<br>指定prefix，直接删掉一个文件夹就够了。　　</p>
<p>　　2、axconfig: port 1 not active</p>
<pre><code>       axconfig: port 2 not active
    出现这样的错误
</code></pre>
<p>　　（1）通过下面的方法卸载<br>　　　　sudo apt-get remove –purge node<br>　　　　sudo apt-get clean<br>　　（2）重新编译安装<br>　　　　sudo .&#x2F;configure<br>　　　　sudo make<br>　　　　sudo make install<br>　　　　重新编译来一边 OK 解决<br>　　（3）查看版本<br>　　　　输入node –v 或者node –version可以查看node.js当前的版本 </p>
<p>　　　　可能出现bash：usr&#x2F;sbin&#x2F;node 没有那个文件或目录 错误，使用sudo node -v </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>vercel绑定域名 解析@cname</title>
    <url>/30233.html</url>
    <content><![CDATA[<p>_vercel	TXT	默认	<br>vc-domain-verify&#x3D;code.quora8.cn,xxxx</p>
<p>code	CNAME	默认	<br>cname.vercel-dns.com</p>
<p>@  A  默认  76.76.21.21</p>
<p>www  CNAME  默认	cname.vercel-dns.com</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>一台电脑配置多个GitHub 或 其他git 仓库账号的方法</title>
    <url>/22981.html</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 取消全局设置</span><br><span class="line">git config --global --unset user.name</span><br><span class="line">git config --global --unset user.email</span><br><span class="line"></span><br><span class="line"># 进入项目目录</span><br><span class="line">git init</span><br><span class="line">git config user.email &quot;xxxxx@xxx.com&quot;</span><br><span class="line">git config user.name &quot;xxxx&quot;</span><br><span class="line"></span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>C#/.NET 中的动态语言运行时</title>
    <url>/2736.html</url>
    <content><![CDATA[<p>C# 中的动态语言运行时 DLR 概述<br>本文讨论动态语言运行时如何在 C#、DynamicObject 和 ExpandoObject 中工作，以及 IronPython 在 .NET 中的最简单用法。<br>介绍<br>尽管 C# 属于静态类型语言，但在该语言的最新版本中添加了一些动态功能。在本文中，我想展示动态语言运行时 (DLR)如何在 C# 中工作，DynamicObject以及IronPython在 .NET 中ExpandoObject的最简单用法。</p>
<p>C# 中的动态语言运行时 DLR<br>DLR（动态语言运行时）自.NET 4.0开始添加，代表IronPython和IronRuby等动态语言的运行时环境。</p>
<span id="more"></span>
<p>为了理解这个创新的本质，你需要知道静态类型和动态类型的语言之间的区别。在具有静态类型的语言中，所有类型及其成员 - 属性和方法的识别发生在编译阶段，而在动态语言中，系统在执行之前对类型的属性和方法一无所知。</p>
<p>由于这个DLR环境，C# 可以创建其成员在程序执行阶段被识别的动态对象，并将它们与具有静态类型的传统对象一起使用。</p>
<p>动态类型的使用是在 C# 中使用DLR的关键点，因此您可以在编译阶段跳过类型检查。此外，声明为动态的对象可以在程序运行期间更改其类型。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">            dynamic x = 3;     // here x is a integer</span><br><span class="line">            Console.WriteLine(x);</span><br><span class="line"> </span><br><span class="line">            x = &quot;Hello world&quot;; // now x is a string</span><br><span class="line">            Console.WriteLine(x);</span><br><span class="line"> </span><br><span class="line">            x = new Item_mast() </span><br><span class="line">                &#123; ItemId=1,ItemDesсription=&quot;Pen&quot;,Cost=10 &#125;; // now x is a Item_mast</span><br><span class="line">            Console.WriteLine(x);</span><br><span class="line">            Console.ReadLine();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  public class Item_mast</span><br><span class="line">        &#123;</span><br><span class="line">            public int ItemId &#123; get; set; &#125;</span><br><span class="line">            public string ItemDesсription &#123; get; set; &#125;</span><br><span class="line">            public int Cost &#123; get; set; &#125;</span><br><span class="line"> </span><br><span class="line">            public override string ToString()</span><br><span class="line">            &#123;</span><br><span class="line">                return ItemId.ToString() + &quot;, &quot;+ ItemDesсription + &quot; &quot; + Cost.ToString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/pic/img202208011001.png" alt="img"><br>图 1 - 基本 DLR 示例<br>让我们稍微描述一下代码。即使变量x多次更改其类型，此代码也可以正常工作。dynamic这是和之间的关键区别var。对于使用var关键字声明的变量，类型在编译时输出，然后在运行时不会更改。此外，您可以注意到dynamic类型和object类型之间的一些相似之处。我们可以很容易地替换表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dynamic x = 3;</span><br></pre></td></tr></table></figure>
<p>至：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">object x = 3</span><br></pre></td></tr></table></figure>
<p>我们有同样的结果。</p>
<p>但是，object类型也存在差异。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">object obj = 24;</span><br><span class="line">dynamic dyn = 24;</span><br><span class="line">obj += 4; // we can not do it!!!</span><br><span class="line">dyn += 4; // now is ok</span><br></pre></td></tr></table></figure>
<p>在行上obj +&#x3D; 4，我们将看到一个错误，因为该+&#x3D;操作不能应用于objectandint类型。使用声明为 的变量dynamic，这是可能的，因为它的类型只会在运行时知道。<br>需要注意的是，dynamic不仅可以应用于变量，还可以应用于方法和属性。让我们进行更改class并考虑下一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Item_mast</span><br><span class="line">        &#123;</span><br><span class="line">            public int ItemId &#123; get; set; &#125;</span><br><span class="line">            public string ItemDesсription &#123; get; set; &#125;</span><br><span class="line">            public dynamic Cost &#123; get; set; &#125; </span><br><span class="line"> </span><br><span class="line">            public dynamic GetPrice(dynamic value, string format)</span><br><span class="line">            &#123;</span><br><span class="line">                if (format == &quot;string&quot;)</span><br><span class="line">                &#123;</span><br><span class="line">                    return value + &quot; dollar&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (format == &quot;int&quot;)</span><br><span class="line">                &#123;</span><br><span class="line">                    return value;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    return 0.0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>Item_mass class定义了一个动态属性，因此在Cost为该属性设置值时，我们可以同时写Item.Cost&#x3D;10.00和Item.Cost&#x3D;”ten”。这两个选项都是正确的。还有一种GetPrice方法可以返回动态值。例如，根据参数，我们可以返回string价格表示或数字表示。该方法还将动态作为参数。因此，我们可以同时传递整数和小数作为收入值。我们来看看具体的应用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dynamic item1 = new Item_mast() &#123; ItemId = 1, ItemDesсription = &quot;Pen&quot;, Cost = 10 &#125;;</span><br><span class="line">            Console.WriteLine(item1);</span><br><span class="line">            Console.WriteLine(item1.GetPrice(10.00, &quot;int&quot;));</span><br><span class="line"> </span><br><span class="line">            dynamic item2 = new Item_mast() </span><br><span class="line">                            &#123; ItemId = 2, ItemDesсription = &quot;Pencil&quot;, Cost = &quot;five&quot; &#125;;</span><br><span class="line">            Console.WriteLine(item2);</span><br><span class="line">            Console.WriteLine(item2.GetPrice(5, &quot;string&quot;));</span><br><span class="line">            Console.ReadLine();</span><br></pre></td></tr></table></figure>

<p>结果，我们将拥有（图 2）：<br><img src="/pic/img202208011002.png" alt="img"><br>图 2 - 使用动态变量示例的结果<br>在这一部分中，我们通过示例检查了动态类型的使用。</p>
<p>DynamicObject 和 ExpandoObject<br>扩展对象<br>C#&#x2F;.NET开发能够创建非常类似于JavaScript中使用的动态对象。这种可能性是通过使用命名空间 Dynamic，特别是ExpandoObject类来提供的。</p>
<p>让我们考虑一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dynamic viewbag = new System.Dynamic.ExpandoObject();</span><br><span class="line">            viewbag.ItemId = 1;</span><br><span class="line">            viewbag.ItemDesсription = &quot;Pen&quot;;</span><br><span class="line">            viewbag.Cost = 10;</span><br><span class="line"></span><br><span class="line">            viewbag.Categories = new List&lt;string&gt; &#123; &quot;Flex&quot;, &quot;Soft&quot;, &quot;Luxury&quot; &#125;;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine($&quot;&#123;viewbag.ItemId&#125; ; </span><br><span class="line">                             &#123;viewbag.ItemDesсription&#125; ; &#123;viewbag.Cost&#125;&quot;);</span><br><span class="line">            foreach (var cat in viewbag.Categories)</span><br><span class="line">                Console.WriteLine(cat);</span><br><span class="line"></span><br><span class="line">            //declare method</span><br><span class="line">            viewbag.IncrementCost = (Action&lt;int&gt;)(x =&gt; viewbag.Cost += x);</span><br><span class="line">            viewbag.IncrementCost(6); // Increase Cost </span><br><span class="line">            Console.WriteLine($&quot;&#123;viewbag.ItemId&#125; ; </span><br><span class="line">                                &#123;viewbag.ItemDesсription&#125; ; &#123;viewbag.Cost&#125;&quot;);</span><br><span class="line"></span><br><span class="line">            Console.ReadLine();</span><br></pre></td></tr></table></figure>
<p>图 3 中的结果：<br><img src="/pic/img202208011003.png" alt="img"><br>图 3 - 使用 ExpandoObject() 的示例<br>动态ExpandoObject对象可以声明任何可以表示各种对象的属性。您还可以使用委托设置方法。</p>
<p>动态对象<br>该类DynamicObject与ExpandoObject. 但是，在 的情况下，我们需要通过继承并实现其方法DynamicObject来创建自己的类：DynamicObject</p>
<p>TryBinaryOperation()：在两个对象之间执行二元运算。等价于标准的二元运算，例如x + y)<br>TryConvert()：执行到特定类型的转换。相当于C#中的基本转换，例如(SomeType)obj<br>TryCreateInstance(): 创建一个对象的实例<br>TryDeleteIndex()：删除索引器<br>TryDeleteMember(): 删除一个属性或方法<br>TryGetIndex()：通过索引器按索引获取元素。在 C# 中，它可以等价于以下表达式int x &#x3D; collection[i]<br>TryGetMember(): 获取财产的价值。相当于访问一个属性，例如，string n &#x3D; item1.ItemDescription<br>TryInvoke(): 调用一个对象作为委托<br>TryInvokeMember(): 方法调用<br>TrySetIndex()：通过索引器按索引设置元素。在 C# 中，它可以等价于以下表达式collection[i] &#x3D; x;<br>TrySetMember(): 设置属性。相当于将一个项目值分配给一个property.Itemdescription &#x3D; “Pen”<br>TryUnaryOperation()：执行类似于 C# 中的一元运算的一元运算：x++<br>这些方法中的每一个都具有相同的检测模型：它们都返回一个布尔值，指示操作是否成功。作为第一个参数，它们都采用活页夹或活页夹对象。如果方法表示对可以接受参数的索引器或对象方法的调用，则object[] 数组用作第二个参数 - 它存储传递给方法或索引器的参数。</p>
<p>几乎所有的操作，除了设置和删除属性和索引器外，都会返回一个特定的值（例如，如果我们获取一个属性的值。在这种情况下，使用第三个参数out对象值，其目的是存储返回的object.</p>
<p>让我们通过创建一个dynamic对象类来举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Item_mast : DynamicObject</span><br><span class="line">        &#123;</span><br><span class="line">            Dictionary&lt;string, object&gt; members = new Dictionary&lt;string, object&gt;();</span><br><span class="line"> </span><br><span class="line">            // set prop</span><br><span class="line">            public override bool TrySetMember(SetMemberBinder binder, object value)</span><br><span class="line">            &#123;</span><br><span class="line">                members[binder.Name] = value;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            // get prop</span><br><span class="line">            public override bool TryGetMember(GetMemberBinder binder, out object result)</span><br><span class="line">            &#123;</span><br><span class="line">                result = null;</span><br><span class="line">                if (members.ContainsKey(binder.Name))</span><br><span class="line">                &#123;</span><br><span class="line">                    result = members[binder.Name];</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            // call method</span><br><span class="line">            public override bool TryInvokeMember</span><br><span class="line">            (InvokeMemberBinder binder, object[] args, out object result)</span><br><span class="line">            &#123;</span><br><span class="line">                dynamic method = members[binder.Name];</span><br><span class="line">                result = method((int)args[0]);</span><br><span class="line">                return result != null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>我们不能直接从 中创建对象DynamicObject，所以我们的Item_mast 类是一个孩子。在我们的类中，我们重新定义了三个方法。我们还使用Dictionary&lt;string, object&gt;成员来存储所有类成员，但我们也将它用于属性和方法。在这本字典中，keyshere 是names属性和方法，而values是values这些属性。<br>使用该TrySetMember() 方法，我们设置属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool TrySetMember(SetMemberBinder binder, object value)</span><br></pre></td></tr></table></figure>
<p>在这里，binder 参数存储要设置的属性的名称（binder.Name），value 是它需要设置的值。<br>TryGetMember是我们用来获取属性值的重写方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool TryGetMember(GetMemberBinder binder, out object result)</span><br></pre></td></tr></table></figure>
<p>同样，活页夹包含属性的名称，结果参数将包含结果的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The TryInvokeMember method is defined for calling methods:</span><br><span class="line"></span><br><span class="line">public override bool TryInvokeMember(InvokeMemberBinder binder, object[] args, out object result)</span><br><span class="line">&#123;</span><br><span class="line">    dynamic method = members[binder.Name];</span><br><span class="line">    result = method((int)args[0]);</span><br><span class="line">    return result != null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，使用 binder，我们获取方法，然后将args[0] 参数传递给它，首先将其转换为int类型，然后在result参数中设置方法的结果。也就是说，在这种情况下，假设该方法将采用该int类型的一个参数并返回一些结果。让我们举一个在我们的应用程序中使用类的例子：<br>现在让我们在程序中应用这个类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">   dynamic item = new Item_mast();</span><br><span class="line">            item.ItemId = 1;</span><br><span class="line">            item.ItemDesсription = &quot;Pen&quot;;</span><br><span class="line">            item.Cost = 10;</span><br><span class="line">            Func&lt;int, int&gt; Incr = delegate (int x) &#123; item.Cost += x; return item.Cost; &#125;;</span><br><span class="line">            item.IncrementCost = Incr;</span><br><span class="line">            Console.WriteLine($&quot;&#123;item.ItemId&#125; ; &#123;item.ItemDesсription&#125; ; &#123;item.Cost&#125;&quot;);         </span><br><span class="line">            item.IncrementCost(6);</span><br><span class="line">            Console.WriteLine($&quot;&#123;item.ItemId&#125; ; &#123;item.ItemDesсription&#125; ; &#123;item.Cost&#125;&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表达式item.ItemId &#x3D; 1 anditem.ItemDescription &#x3D; “Pen”将调用TrySetMember方法，数字将作为第一个变体中的第二个参数传递给该方法，而字符串 “Pen” 将在第二个变体中传递。<br>返回item.Cost 调用TryGetMember方法。<br>此外，该item对象还IncrementCost定义了一个方法，该方法表示匿名委托的操作delegate (int x) { item.Cost+&#x3D;x; return item.Cost; }。委托获取数字x，将Cost属性增加此数字并返回新值item.Cost.。当调用此方法时，TryInvokeMember将访问该方法。因此，item.Cost财产的价值将增加。</p>
<p>优点是您可以在使用动态对象时重新定义动态对象的行为，即，您实际上可以自己实现可动态扩展的对象。</p>
<p>在这一部分中，我们检查了示例的用法DynamicObject和ExpandoObject示例。</p>
<p>在 .NET 中使用 IronPython。<br>看起来为什么我们需要更多的语言，尤其是那些在另一种 C# 语言中使用的语言？但是，DLR环境的关键点之一是对IronPython和IronRuby等语言的支持。这在编写功能性客户端脚本时很有用。甚至可以说，现在客户端脚本的创建已经很普遍了，很多程序甚至游戏都支持添加用各种语言编写的客户端脚本。此外，可能有一些Python库的功能在 .NET 中可能不可用。在这种情况下，IronPython 可以再次帮助我们。</p>
<p>让我们看一个例子。首先，我们需要添加所有必要的NuGet包。为此，我将使用批处理管理器。首先，让我们添加DLR包（图 4）。</p>
<p>图 4<br><img src="/pic/img202208011004.png" alt="img"><br>图 4 - 添加 DLR 包<br>接下来，添加IronPython（图 5）：</p>
<p>图 5<br><img src="/pic/img202208011005.png" alt="img"><br>图 5 - 添加 IronPython 包<br>让我们添加最简单的代码，并且我们已经使用了 python：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            ScriptEngine engine = Python.CreateEngine();</span><br><span class="line">            engine.Execute(&quot;print &#x27;hello, world&#x27;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>结果，我们有（图6）：</p>
<p>图 6<br><img src="/pic/img202208011006.png" alt="img"><br>图 6 - 使用 IronPyton<br>这里使用了 Python 表达式，print ‘hello, world’ 它将 a 输出string到控制台。要创建执行脚本的引擎，需要ScriptEngine使用该类。它的Execute()方法执行脚本。<br>此外，我们可以创建一个文件，例如helloword.py并将文件的内容直接粘贴到我们的代码中：</p>
<p>engine.ExecuteFile(“D:&#x2F;&#x2F;helloword.py”);<br>此外，该ScriptScope对象允许您通过接收或安装脚本与脚本进行交互。但是，这已经超出了本文的范围。</p>
<p>结论<br>总之，我们研究了动态语言运行时 (DLR) 在 C# 中的工作方式、如何使用DynamicObject以及ExpandoObjectIronPython 如何在 .NET 中最简单的示例中工作。</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>微软</tag>
      </tags>
  </entry>
  <entry>
    <title>C#中的寻路算法</title>
    <url>/560.html</url>
    <content><![CDATA[<p>下载源 - 571.3 KB<br><a href="https://www.codeproject.com/KB/Articles/1221034/Source.zip">https://www.codeproject.com/KB/Articles/1221034/Source.zip</a><br>Path finding challenge<br><a href="http://airobots.azurewebsites.net/">http://airobots.azurewebsites.net/</a></p>
<p>在 Visual Studio 2017 中解压缩并打开解决方案</p>
<p>介绍<br>您有没有想过 GPS 应用程序如何计算到达所选目的地的最快方式？正如您将看到的，它实际上非常简单。</p>
<p>本文对此进行了解释，并提供了您可以随意使用的示例代码。文章还比较了两种常见的基本算法，Dijkstra 和 A*。</p>
<p>问题<br>假设你有一张地图。你知道你在哪里，你想去哪里。地图有连接节点（有坐标的地方）的道路（它们被称为边）。</p>
<p>从每个节点，你可以去一个或多个边。一条边有一个成本（例如，通过它所需的长度或时间）。<br>对于小地图，也许可以计算到目的地的所有可能路线并选择最短的路线。但这对于具有许多节点的地图来说不是很实用，因为组合呈指数增长。</p>
<span id="more"></span>
<p>迪杰斯特拉<br>Dijkstra 算法由 Edsger Dijkstra 于 1959 年发现。这是它的工作原理：</p>
<p>从起始节点开始，将所有连接的节点添加到优先级队列中。<br>按最低成本对优先级队列进行排序，并使第一个节点成为当前节点。<br>对于每个子节点，选择通向最短路径的最佳开始。<br>当从一个节点调查所有边时，该节点是“ Visited”，你不需要再去那里。<br>将连接到当前节点的每个子节点添加到优先级队列中。<br>转到第 2 步，直到队列为空。<br>递归地创建从头到尾引导最短路径的每个节点节点的列表。<br>反转列表，您找到了最短路径<br>换句话说，对于节点的每个子节点，递归地测量它到起点的距离。存储距离和哪个节点导致开始的最短路径。当您到达结束节点时，以最短的方式递归地回到起点，反转该列表，您就有了最短路径。</p>
<p>下面是我在 C# 代码中的 Dijkstra 算法实现。可能比上面的更容易理解。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Node&gt; <span class="title">GetShortestPathDijkstra</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    DijkstraSearch();</span><br><span class="line">    <span class="keyword">var</span> shortestPath = <span class="keyword">new</span> List&lt;Node&gt;();</span><br><span class="line">    shortestPath.Add(End);</span><br><span class="line">    BuildShortestPath(shortestPath, End);</span><br><span class="line">    shortestPath.Reverse();</span><br><span class="line">    <span class="keyword">return</span> shortestPath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BuildShortestPath</span>(<span class="params">List&lt;Node&gt; list, Node node</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.NearestToStart == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    list.Add(node.NearestToStart);</span><br><span class="line">    BuildShortestPath(list, node.NearestToStart);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DijkstraSearch</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Start.MinCostToStart = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> prioQueue = <span class="keyword">new</span> List&lt;Node&gt;();</span><br><span class="line">    prioQueue.Add(Start);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prioQueue = prioQueue.OrderBy(x =&gt; x.MinCostToStart).ToList();</span><br><span class="line">        <span class="keyword">var</span> node = prioQueue.First();</span><br><span class="line">        prioQueue.Remove(node);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> cnn <span class="keyword">in</span> node.Connections.OrderBy(x =&gt; x.Cost))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> childNode = cnn.ConnectedNode;</span><br><span class="line">            <span class="keyword">if</span> (childNode.Visited)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (childNode.MinCostToStart == <span class="literal">null</span> ||</span><br><span class="line">                node.MinCostToStart + cnn.Cost &lt; childNode.MinCostToStart)</span><br><span class="line">            &#123;</span><br><span class="line">                childNode.MinCostToStart = node.MinCostToStart + cnn.Cost;</span><br><span class="line">                childNode.NearestToStart = node;</span><br><span class="line">                <span class="keyword">if</span> (!prioQueue.Contains(childNode))</span><br><span class="line">                    prioQueue.Add(childNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node.Visited = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (node == End)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (prioQueue.Any());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是我的测试程序中随机生成的地图。点是节点，它们之间是代表边的线。该地图由 5000 个节点和 15000 条边组成。</p>
<p>搜索算法会访问较浅颜色的点，并以绿色绘制最佳路径。</p>
<p>A* 算法<br>Dijkstra 算法有很多改进。最常见的一种称为 A*。它与 Dijkstra 基本相同，只是做了一个简单的修改。</p>
<p>边缘的优先级还取决于该边缘与目标的直线距离有多近。因此，在运行 A* 搜索之前，必须测量每个节点到最终目的地的直线距离，如果您知道每个节点的坐标，这很容易。这是 A* 的最简单形式，它的定义还允许改进启发式函数。（在本例中为 StraightLineDistanceToEnd）</p>
<p>该算法具有很大的性能优势，因为当路径末端的方向已知时，它不需要访问尽可能多的节点。</p>
<p>请参阅下面的实现。以粗体显示添加到 Dijkstra 算法的内容。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Node&gt; <span class="title">GetShortestPathAstar</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> node <span class="keyword">in</span> Map.Nodes)</span><br><span class="line">        node.StraightLineDistanceToEnd = node.StraightLineDistanceTo(End);</span><br><span class="line">    AstarSearch();</span><br><span class="line">    <span class="keyword">var</span> shortestPath = <span class="keyword">new</span> List&lt;Node&gt;();</span><br><span class="line">    shortestPath.Add(End);</span><br><span class="line">    BuildShortestPath(shortestPath, End);</span><br><span class="line">    shortestPath.Reverse();</span><br><span class="line">    <span class="keyword">return</span> shortestPath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AstarSearch</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Start.MinCostToStart = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> prioQueue = <span class="keyword">new</span> List&lt;Node&gt;();</span><br><span class="line">    prioQueue.Add(Start);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prioQueue = prioQueue.OrderBy(x =&gt; x.MinCostToStart + x.StraightLineDistanceToEnd).ToList();</span><br><span class="line">        <span class="keyword">var</span> node = prioQueue.First();</span><br><span class="line">        prioQueue.Remove(node);</span><br><span class="line">        NodeVisits++;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> cnn <span class="keyword">in</span> node.Connections.OrderBy(x =&gt; x.Cost))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> childNode = cnn.ConnectedNode;</span><br><span class="line">            <span class="keyword">if</span> (childNode.Visited)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (childNode.MinCostToStart == <span class="literal">null</span> ||</span><br><span class="line">                node.MinCostToStart + cnn.Cost &lt; childNode.MinCostToStart)</span><br><span class="line">            &#123;</span><br><span class="line">                childNode.MinCostToStart = node.MinCostToStart + cnn.Cost;</span><br><span class="line">                childNode.NearestToStart = node;</span><br><span class="line">                <span class="keyword">if</span> (!prioQueue.Contains(childNode))</span><br><span class="line">                    prioQueue.Add(childNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node.Visited = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (node == End)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (prioQueue.Any());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是与上面相同的地图，但路径是使用 A* 算法计算的。如您所见，需要访问的节点要少得多。</p>
<p>结果<br>在 500,000 个节点的同一张地图上运行这两种算法时，我得到了这些结果。</p>
<pre><code>                                Dijkstra	                    A*
</code></pre>
<p>Visited nodes	    330,871	               19,410<br>Time to calculate (ms)        850	                   127<br>Cost of best path	     14,322	               22,994<br>Distance of shortest path 0,82446           0,82446</p>
<p>如上表所示，A* 算法比 Dijkstra 快 7 倍左右，并且它们都找到了最短路径。<br>但是，当为边的成本生成随机数时，Dijkstra 会找到一条成本更低的路径。<br>例如，在真实地图中，最短路径并不总是最好的。在限速较高的道路上行驶可能会让您更快到达目的地。这就是为什么在边的成本中添加一个随机数会使这个实验更加现实。</p>
<p>结论<br>那么 Dijkstra 和 A* 的最佳寻路算法是什么算法呢？<br>我会说这取决于。如果您只对最短路径感兴趣，那就是 A<em>。<br>它要快得多，并且给出与 Dijkstra 相同的结果。但是，如果边的成本还有其他方面而不是其长度，那么 Dijkstra 在找到最佳路径方面比这个版本的 A</em> 更好。毕竟，它仍然非常快。我认为 500,000 个节点是一个非常大的数据集。我也认为我的实现可以优化很多。</p>
<p>挑战<br>如果您还幼稚地喜欢编程挑战，也许您想对机器人进行编程以找到迷宫的出路？</p>
<p>您可能需要一些寻路算法来解决它。<br>请参阅此站点：  http :&#x2F;&#x2F;airobots.azurewebsites.net&#x2F;</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>微软</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言 快速概览</title>
    <url>/48578.html</url>
    <content><![CDATA[<p>在本文中，我们将快速概述 Google 的 Go 编程语言。</p>
<p>目录</p>
<ol>
<li>介绍</li>
<li>Go Hello, World!</li>
<li>注释</li>
<li>分号</li>
<li>功能<br> 入口点</li>
<li>变量<br> 短变量声明</li>
<li>内置类型</li>
<li>用户定义的类型<br> 结构<br> 界面</li>
<li>数组</li>
<li>切片</li>
<li>常数</li>
<li>指针</li>
<li>声明</li>
<li>匿名函数<br> 闭包</li>
<li>方法</li>
<li>参考</li>
<li>历史</li>
</ol>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Go 是一种由 Google 创建的通用编程语言。这是一个开源项目，旨在提高程序员的工作效率。Go 非常有表现力和干净。它的并发编程能力帮助程序员编写需要充分利用多核和联网机器的程序。Go 是静态类型和编译的编程语言。Go 将程序快速编译成机器代码。它还具有垃圾收集功能。垃圾收集使并发代码更容易编写。除此之外，Go 还有一个非常丰富的标准库。</p>
<span id="more"></span>
<p>Go Hello, World!<br>让我们看看下面的“你好，世界！” 用 Go 编写的程序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个 hello world 程序中，我们得到了以下内容：</p>
<ol>
<li>一个名为main的包名。但实际上它是什么？</li>
</ol>
<p>好吧，每个 Go 程序都是由包组成的。我们要么编写一个库，要么编写一个可执行程序。可执行程序属于包main。这意味着可执行程序开始在包main中运行。所以在一个 Go 程序的开头，需要通过以下方式指定包名：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br></pre></td></tr></table></figure>

<p>这将告诉编译器这个程序是一个可执行程序。不是图书馆。</p>
<p>但是如果我们写了一个库，这意味着我们正在写一个新的包，我们给这个包起个名字。假设我们的新库&#x2F;包名称将是‘simplelib’. 如果是这样，那么在我们新库&#x2F;包的每个源文件的开头，必须存在以下行：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simplelib</span><br></pre></td></tr></table></figure>
<p>这就是我们告诉编译器这个源文件属于包’ simplelib ‘的方式。</p>
<ol start="2">
<li>我们发现了一个 import 语句，它正在导入名为“ fmt ”的东西。</li>
</ol>
<p>import 语句用于将外部 Go 包导入另一个 Go 包&#x2F;程序。非常类似于 C 的 include 预处理器指令。</p>
<p>import 语句的使用方式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;package_name&quot;</span></span><br></pre></td></tr></table></figure>

<p>或者（在导入多个包时推荐使用此语法）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;package_name&quot;</span></span><br><span class="line">    <span class="string">&quot;package_name2&quot;</span></span><br><span class="line">    <span class="string">&quot;package_name3&quot;</span></span><br><span class="line">    <span class="string">&quot;package_nameN&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在 hello world 示例中，导入了一个名为fmt的包。包fmt使用类似于 Cprintf和scanf. “动词”格式源自 C，但更简单。所以这个包在与控制台窗口交互时是必需的。</p>
<ol start="3">
<li>一个名为 的用户定义函数main。</li>
</ol>
<p>这个函数类似于 C 的入口点main。Go 程序的代码执行从这个函数开始。</p>
<ol start="4">
<li>在main函数内部，另一个名为的函数Println被调用以打印“Hello, World!”。信息。</li>
</ol>
<p>该Println函数用于在控制台窗口上打印一些东西。这个函数属于 fmt 包，这就是为什么这个包是在 hello world 程序的一开始就被导入的。</p>
<p>GoPrintln非常有用。我们可以使用此函数打印字符串或整数等值。甚至，我们可以打印更复杂的东西，比如数组。我们不需要任何循环来打印数组的元素。该Println函数在打印所有值后自动插入换行符。</p>
<p>现在，我们将介绍 Go 编程语言的一些特性。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>我们程序员使用注释来描述一段代码。这使得代码更容易理解和阅读。Go 中的注释主要有两种形式：</p>
<p>单行注释<br>多行注释<br>以下是单行注释的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This is a single line comment.</span></span><br></pre></td></tr></table></figure>
<p>以下是多行注释的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is a multi line comment.</span></span><br><span class="line"><span class="comment">   This is the second line of this multi line comment.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>现在我们可以看到，在 Go 中做注释类似于 C++、C#、Java 等。</p>
<h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><p>与 C、C++、C#、Java 等编程语言不同，Go 中不需要使用分号来指示语句的终止。Go 的词法分析器使用一个简单的规则来推断语句的结尾。</p>
<p>惯用的 Go 程序仅在诸如 for 循环子句之类的地方使用分号来分隔初始值设定项、条件和延续元素。它们也是分隔一行中的多个语句所必需的。</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>在 Go 中，函数创建具有以下语法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">(input_parameter_list)</span></span> (return_type_list) &#123;</span><br><span class="line">    function_stataments</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到函数创建以 func 关键字开始。然后我们必须指定函数的名称。函数的名称应该是任何有效的 Go 标识符。之后，我们把所有的输入参数。如果一个函数的参数列表中有多个参数，则需要用逗号分隔。而且，参数必须由大括号()包围。然后我们指定函数的返回类型。但是如果我们的函数不需要返回任何值，那么我们可以省略返回类型。</p>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sing</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// I&#x27;m singing!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个在两个数字之间进行加法并将结果作为整数值返回的函数示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 C 不同，Go 中的函数可以有多个返回值，这是一个内置特性。在这种情况下，返回类型需要用大括号 ( ) 括起来，并且所有返回类型都必须通过逗号运算符分隔。</p>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getall</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>, <span class="string">&quot;that&#x27;s all!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而当我们调用该函数时，会通过这种方式获取多个返回值（本示例代码使用短变量声明形式，我们将在“短变量声明”部分讨论）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i, s := getall()</span><br></pre></td></tr></table></figure>

<p>现在变量i包含第一个返回值（即10）并且变量s包含第二个返回值（它是一个字符串并且是“就是这样！”）。</p>
<p>在 Go 中，这种多返回值特性通常用于从函数返回结果值和错误值。</p>
<p>入口点<br>一个名为 as 的全局函数main被识别为程序的入口点：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">    <span class="comment">// function’s body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，Go 的 main 函数没有用于访问命令行参数的参数（如 C 中的 ,​​ ）argc。argv但是，一个名为os的 Go 包提供了该问题的解决方案。os包的Args变量提供对原始命令行参数的访问。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(os.Args), os.Args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Go 中的变量声明具有以下语法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier_list类型</span><br><span class="line"><span class="keyword">var</span> identifier_list = initializer_expression_list</span><br><span class="line"><span class="keyword">var</span> identifier_list <span class="keyword">type</span> = initializer_expression_list</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> a, b, c <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> k = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span> = <span class="number">12</span>, <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到 Go 中的变量声明以var关键字开头。而且，并不总是需要明确指定类型。我们可以让编译器从初始化表达式中推断出变量的类型。这就像我们在 C++11 中使用auto关键字一样。</p>
<p>短变量声明<br>短变量声明具有以下语法，不需要在声明开头使用var关键字并自动推断变量的类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">identifier_list := initializer_expression_list</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a, b, c := <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>这使编码更容易，并有助于更快地编写代码。</p>
<p>请注意，短变量声明形式只能在函数内部使用。您不能在全局范围内使用它。</p>
<h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><p>以下是 Go 中可用的所有基本&#x2F;内置类型的列表：</p>
<p>bool - 由两个预定义的常量true和false组成<br>string - 表示字符序列<br>int8 - 有符号 8 位整数（-128 到 127）<br>int16 - 有符号 16 位整数（-32768 到 32767）<br>int32 - 有符号 32 位整数（-2147483648 到 2147483647）<br>int64 - 有符号 64 位整数（-9223372036854775808 到 9223372036854775807）<br>int - 带符号的 32 位或 64 位整数（取决于系统）<br>uint8 - 无符号 8 位整数（0 到 255）<br>uint16 - 无符号 16 位整数（0 到 65535）<br>uint32 - 无符号 32 位整数（0 到 4294967295）<br>uint64 - 无符号 64 位整数（0 到 18446744073709551615）<br>uint - 无符号 32 或 64 位整数（取决于系统）<br>uintptr - 无符号 32 或 64 位整数（取决于系统）<br>字节（uint8 的别名）<br>符文（ int32 的别名）<br>float32 - IEEE-754 32 位浮点数<br>float64 - IEEE-754 64 位浮点数<br>complex64 - 具有 float32 实部和虚部的复数<br>complex128 - 具有 float64 实部和虚部的复数<br>注意：int、uint和uintptr类型在 32 位系统上通常为 32 位宽，在 64 位系统上通常为 64 位宽。当您需要一个整数值时，您应该使用int，除非您有特定的理由使用一个大小调整或无符号整数类型。</p>
<h2 id="用户定义的类型"><a href="#用户定义的类型" class="headerlink" title="用户定义的类型"></a>用户定义的类型</h2><p>Go 中用户自定义类型主要有两种：</p>
<p>结构<br>界面<br>结构<br>结构允许程序员将多个相同或不同类型的变量保存在一起。</p>
<p>在 Go 中，需要使用type和struct关键字来创建结构。创建结构的语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> identifier <span class="keyword">struct</span> &#123;</span><br><span class="line">    structure_members</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由四个相同类型的变量组成的结构示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    left <span class="type">int</span></span><br><span class="line">    top <span class="type">int</span></span><br><span class="line">    right <span class="type">int</span></span><br><span class="line">    bottom <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由三个不同类型的变量组成的结构的另一个示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    income <span class="type">float32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构使用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rect Rectangle</span><br><span class="line"></span><br><span class="line">rect.left = <span class="number">20</span></span><br><span class="line">rect.top = <span class="number">10</span></span><br><span class="line">rect.right = <span class="number">50</span></span><br><span class="line">rect.bottom = <span class="number">60</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;left: &quot;</span>, rect.left)</span><br><span class="line">fmt.Println(<span class="string">&quot;top: &quot;</span>, rect.top)</span><br><span class="line">fmt.Println(<span class="string">&quot;right: &quot;</span>, rect.right)</span><br><span class="line">fmt.Println(<span class="string">&quot;bottom: &quot;</span>, rect.bottom)</span><br></pre></td></tr></table></figure>
<p>Go 允许在变量声明期间初始化结构的成员：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = Rectangle&#123;<span class="number">20</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">60</span>&#125;</span><br></pre></td></tr></table></figure>
<p>界面<br>Go 中接口的语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> identifier <span class="keyword">interface</span> &#123;</span><br><span class="line">    interface_methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">    Name() <span class="type">string</span></span><br><span class="line">    Age() <span class="type">int</span></span><br><span class="line">    Flee()</span><br><span class="line">    Die()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个使用接口的实际示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Greeting <span class="keyword">interface</span> &#123;</span><br><span class="line">    Say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> EngGreeting <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Implement the Greeting interface.</span></span><br><span class="line">    Greeting</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BanGreeting <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Implement the Greeting interface.</span></span><br><span class="line">    Greeting</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e * EngGreeting)</span></span> Say() &#123;</span><br><span class="line">    <span class="comment">// Implement method Say for EngGreeting struct.</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello Forhad Reja&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e * BanGreeting)</span></span> Say() &#123;</span><br><span class="line">    <span class="comment">// Implement method Say for BanGreeting struct.</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;ওহে ফরহাদ রেজা&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function doesn&#x27;t care whether &#x27;g&#x27; will be a Bengali or English greeting ;)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(g Greeting)</span></span> &#123;</span><br><span class="line">    g.Say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// create an instance of EngGreeting.</span></span><br><span class="line">    e := <span class="built_in">new</span>(EngGreeting)</span><br><span class="line">    say(e)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create an instance of BanGreeting.</span></span><br><span class="line">    b := <span class="built_in">new</span>(BanGreeting)</span><br><span class="line">    say(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>Go 中的数组创建语法与 C++、C# 等编程语言略有不同。方括号放在元素类型之前：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[ array_length_expression ] element_type</span><br></pre></td></tr></table></figure>
<p>数组长度表达式必须是大于零的整数常量。</p>
<p>创建单维和多维数组的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ar [<span class="number">10</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> mat [<span class="number">4</span>][<span class="number">4</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> big [<span class="number">10</span>][<span class="number">10</span>][<span class="number">10</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure>
<p>数组可以在创建时初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ar = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">12</span>, <span class="number">10</span>, <span class="number">32</span>&#125;</span><br></pre></td></tr></table></figure>
<p>让我们看一个为数组的单个元素赋值的例子。请注意，数组的索引从 0 开始，最后一个索引比数组的总长度小一：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ar[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">mat[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>访问数组的单个元素：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(ar[<span class="number">0</span>], mat[<span class="number">0</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>Go 中没有内置的动态数组。但是等等……有切片。</p>
<p>切片允许我们动态增加数组的大小。在 Go 中可以使用以下语法创建切片：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[  ] element_type</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> da []<span class="type">int</span> = []<span class="type">int</span>&#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(da)</span><br></pre></td></tr></table></figure>
<p>打印输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">9</span> <span class="number">8</span> <span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<p>Go 具有对切片&#x2F;动态数组执行操作的内置函数。这是使用内置append函数向数组添加新项目的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">da = <span class="built_in">append</span>(da, <span class="number">4</span>)</span><br><span class="line">fmt.Println(da)</span><br></pre></td></tr></table></figure>
<p>现在它打印：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h2 id="常数"><a href="#常数" class="headerlink" title="常数"></a>常数</h2><p>常量是在程序执行期间无法更改的固定值。常量声明以const关键字开头。语法类似于变量声明的语法，只是将var关键字替换为const关键字：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi <span class="type">float64</span> = <span class="number">3.14159265358979323846</span></span><br><span class="line"><span class="keyword">const</span> zero = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	size <span class="type">int64</span> = <span class="number">1024</span></span><br><span class="line">	eof        = <span class="number">-1</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> a, b, c = <span class="number">3</span>, <span class="number">4</span>, <span class="string">&quot;foo&quot;</span></span><br><span class="line"><span class="keyword">const</span> u, v <span class="type">float32</span> = <span class="number">0</span>, <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>与 C、C++ 一样，Go 支持指针。我们可以创建指针变量来保存另一个变量的地址。并且通过指针变量，我们可以给原来的变量赋值。&amp;运算符用于获取变量的地址，星号*运算符用于取消引用。</p>
<p>要创建具有显式类型的指针变量，必须将“ * ”符号放在类型名称之前。</p>
<p>创建具有显式类型的指针变量的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span></span><br></pre></td></tr></table></figure>
<p>用法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create a value type variable</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">42</span></span><br><span class="line"><span class="comment">// let’s get the address of the variable ‘n’</span></span><br><span class="line">p = &amp;n</span><br><span class="line"><span class="comment">// now, through the pointer variable ‘p’, assign 10 to the variable ‘n’</span></span><br><span class="line">*p = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>现在，如果我们打印变量 的值n，我们将得到10。</p>
<p>我们还可以使用短变量声明形式创建指针：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p := &amp;n</span><br></pre></td></tr></table></figure>
<p>需要注意的一点是，Go 没有指针算法。这意味着您不能简单地执行类似p++or的操作p +&#x3D; 1。</p>
<p>所以下面的语句：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p++</span><br></pre></td></tr></table></figure>
<p>会产生这个错误：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">invalid operation: p++ (non-numeric <span class="keyword">type</span> *<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>Go中有很多种语句。我们将讨论其中的几个。</p>
<p>If&#x2F;Else 语句</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_expression &#123;</span><br><span class="line">	<span class="comment">// if body</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// else body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if&#x2F;else语句在条件下起作用。如果给定条件表达式的计算结果为真，则执行“ if ”主体的代码，否则，如果存在，则执行“ else ”主体的代码。</p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">7</span>%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;7 is even&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;7 is odd&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用 ‘ if ‘ 而不使用 ‘ else ‘。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> age == <span class="number">12</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;too young&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，Go 中的条件不需要括号，而 C++、C#、Java 等编程语言通常需要。而且，Go 中没有三元运算符。即使是基本条件，您也必须使用完整的 if 语句。</p>
<p>对于声明</p>
<p>for是 Go 唯一的循环语句。Go中没有这样的 while、do-while、foreach等循环语句。虽然，Go 的 for 语句可以涵盖所有这些。</p>
<p>以下是for语句的最简单形式，其工作方式与 while 循环语句类似：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="number">10</span> &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典的初始&#x2F;条件&#x2F;之后 for 循环：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是带有范围子句的 for 语句的另一种形式。此表单用于迭代切片或映射：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ar := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> ar &#123;</span><br><span class="line">   fmt.Printf(i, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在切片上进行测距时，每次迭代都会返回两个值。第一个是索引，第二个是该索引处元素的副本。</p>
<p>切换语句</p>
<p>Go 的switch语句与 C++ 的 switch 语句非常相似，只是每个 case 主体都会自动中断。不需要显式地放置一个break语句：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> age &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Kid&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Teen&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Why are you?&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然，可以使用 fallthrough 语句将一个案例转移到下一个案例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> age &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Kid&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Teen&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Why are you?&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>延迟声明</p>
<p>defer语句用于调用不会立即执行的函数。而是将执行推迟到周围函数返回的那一刻。defer 语句通常用于简化执行各种清理操作的函数。</p>
<p>让我们看一个 defer 语句如何工作的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Hoorraa!… I’m deferred!&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Yeah… I’m also deferred!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Stop deferring!&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印以下内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Stop deferring!</span><br><span class="line">Yeah… I’m also deferred!</span><br><span class="line">Hoorraa!… I’m deferred!</span><br></pre></td></tr></table></figure>
<p>现在我们可以看到执行顺序完全颠倒了。这就是 defer 语句的实际工作方式。最后一个延迟函数调用在周围函数返回时首先执行。</p>
<p>另一个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Print(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>Go 语言支持匿名函数。当我们想要创建没有名称的函数时，匿名函数很有用！它们通常被称为 lambda 函数或简称为lambda。</p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// put a function into variable ‘greeting’</span></span><br><span class="line">greeting := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let’s invoke the function</span></span><br><span class="line">greeting()</span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>Go 的匿名函数可以形成闭包。闭包是一个函数值，它从其主体外部引用变量。该函数可以访问并分配给引用的变量；从这个意义上说，函数与变量“绑定”。</p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	num := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		num += x</span><br><span class="line">		<span class="keyword">return</span> num</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pos, neg := adder(), adder()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(pos(i), neg(-i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Go 没有课程。但是，我们可以在结构类型上定义方法。方法基本上是具有特殊接收器参数的函数。接收器参数出现在其自己的参数列表中，位于func关键字和方法名称之间。</p>
<p>在下面的示例中，我们将为结构实现两个名为width和height的方法Rectangle：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    left <span class="type">int</span></span><br><span class="line">    top <span class="type">int</span></span><br><span class="line">    right <span class="type">int</span></span><br><span class="line">    bottom <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rectangle)</span></span> width() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.right - r.left</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> height() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.bottom - r.top</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := Rectangle&#123;<span class="number">20</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;width: &quot;</span>, r.width())</span><br><span class="line">    fmt.Println(<span class="string">&quot;height: &quot;</span>, r.height())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">width: <span class="number">30</span></span><br><span class="line">height: <span class="number">40</span></span><br></pre></td></tr></table></figure>
<p>我们可以使用值类型或指针类型作为接收器参数。Go 自动处理方法调用的值和指针之间的转换。不过，您可能希望使用指针接收器类型来避免复制方法调用或允许该方法修改接收结构的数据。</p>
<p>参考<br><a href="https://golang.org/">https://golang.org</a><br><a href="https://tour.golang.org/">https://tour.golang.org</a><br><a href="https://gobyexample.com/">https://gobyexample.com</a></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>微软</tag>
      </tags>
  </entry>
  <entry>
    <title>p20220805</title>
    <url>/176.html</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">C1</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fun f1()</span><br><span class="line"> a();</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>U++ 2022.2 入门</title>
    <url>/56409.html</url>
    <content><![CDATA[<p>安装及初看U++平台<br>本文提供有关 U++ 环境的基本信息以及在您的计算机上安装它所需的步骤。<br>目录</p>
<ol>
<li>我为什么要在乎？</li>
<li>在哪里下载</li>
<li>Linux、FreeBSD 和 OpenSolaris 安装</li>
<li>OpenBSD 特定说明</li>
<li>视窗</li>
<li>苹果系统</li>
<li>选择主包对话框</li>
<li>尝试第一个示例</li>
<li>将 TheIDE 安装到 Linux 桌面菜单中</li>
<li>如何启动新项目</li>
<li>UppHub</li>
<li>接下来是什么</li>
</ol>
<span id="more"></span>

<h2 id="我为什么要在乎？"><a href="#我为什么要在乎？" class="headerlink" title="我为什么要在乎？"></a>我为什么要在乎？</h2><p>U++ 是一个开源 C++ 框架&#x2F;开发环境，目前最适合具有雄心勃勃的项目的小型团队，这些项目可以做“真正的事情”，例如设计建筑物的工程应用程序、风电场模拟、销售点终端、SQL 客户端-服务器办公室议程、业务销售或复杂的网站后端（是的，我在这里列出了真实世界的示例）。然而，它也可以从最小的实用程序中很好地扩展，正如可以在此处看到的那样。</p>
<p>它是围绕一些相当极端的原则设计的，以最大限度地提高开发人员的生产力和性能。</p>
<p>虽然 C++ 语言的复杂性无法抽象出来（但绝对是实现生产力和性能目标所必需的），但有经验的 U++ 程序员可能会发现自己在 U++ 中执行任务比使用“易于使用”的脚本语言（如 Python）更有效率，是我们的最终目标。</p>
<p>同时，U++ 核心库在字符串操作和映射等领域提供的性能比标准 C++ 库高约 3 倍，这些领域在许多场景中都包含大量负载（例如处理 JSON 或解析文件）。</p>
<p>最重要的是源代码的模块化系统和相应的构建系统，这使得大型项目的管理变得更加简单。</p>
<p>一个事实总结一下：完全重建 U++ 开发环境(TheIDE) 和调试模式下的所有框架库只需要45 秒。（您实际上可以在安装后立即尝试，因为 TheIDE 源是发行版的一部分）。</p>
<p>它在一个演示示例中也有一张漂亮的猫图片！</p>
<p>U++ 目前适用于Windows、X11和MacOS平台。</p>
<h2 id="在哪里下载"><a href="#在哪里下载" class="headerlink" title="在哪里下载"></a>在哪里下载</h2><p>稳定版本可以在<a href="https://sourceforge.net/projects/upp/%E6%89%BE%E5%88%B0%E3%80%82">https://sourceforge.net/projects/upp/找到。</a></p>
<p>U++ 目前作为 LZMA 压缩档案发布（.7z 用于 Windows，.xz 用于 POSIX &#x2F; MacOS）。</p>
<h2 id="Linux、FreeBSD-和-OpenSolaris-安装"><a href="#Linux、FreeBSD-和-OpenSolaris-安装" class="headerlink" title="Linux、FreeBSD 和 OpenSolaris 安装"></a>Linux、FreeBSD 和 OpenSolaris 安装</h2><p>在 Linux 中，必须为目标发行版编译 U++，同时满足依赖关系。然而，对于大多数流行的 Linux 风格来说，这个过程是快速的并且大部分是自动化的。解压存档后，cd到upp文件夹并运行.&#x2F;install脚本：<br><img src="/pic/u2022080101.png" alt="img"><br>该脚本应该能够检测您的 Linux 发行版并建议安装所需依赖项的命令。如果您不介意共享 sudo 密码，它甚至可以安装这些，或者您可以将命令复制到单独的终端并自己运行。.&#x2F;install对于 FreeBSD 和 OpenSolaris 派生系统，相同的过程也应该可以正常工作。</p>
<p>之后，将从源代码编译开发环境，这在现代 x86 CPU 上需要几分钟（在 Raspberry PI 4 上大约需要 15 分钟）：<br><img src="/pic/u2022080102.png" alt="img"><br>之后，.&#x2F;theide生成二进制文件，可以立即使用脚本启动它，您应该会看到如下内容：<br><img src="/pic/u2022080103.png" alt="img"><br>注意：除非您将ide 二进制文件移到其他地方，否则它不会在upp目录之外写入任何内容。一旦你对 U++ 感到厌烦，就删除upp。</p>
<p>此后，在所有平台上使用 TheIDE 基本相同。</p>
<h2 id="OpenBSD-特定说明"><a href="#OpenBSD-特定说明" class="headerlink" title="OpenBSD 特定说明"></a>OpenBSD 特定说明</h2><p>在 OpenBSD 中，您需要在运行.&#x2F;install脚本之前手动解决依赖关系，方法是运行：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pkg_add bash pkgconfig</span><br></pre></td></tr></table></figure>
<p>（只要您在安装 U++ 之前安装了桌面环境，这应该可以工作。）</p>
<p>还需要将&#x2F;etc&#x2F;login.conf中允许的内存大小增加到：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span>:\</span><br><span class="line">    :datasize-max=<span class="number">4096</span>M:\</span><br><span class="line">    :datasize-cur=<span class="number">4096</span>M:\</span><br><span class="line">    :stacksize-cur=<span class="number">512</span>M:\</span><br></pre></td></tr></table></figure>
<p>否则编译器将耗尽内存。之后，按照 Linux 的说明进行操作。</p>
<h2 id="视窗"><a href="#视窗" class="headerlink" title="视窗"></a>视窗</h2><p>在 Windows 中，TheIDE 是预编译的，U++ 带有所有需要的依赖项，包括 clang 编译器。只需解压缩存档并启动theide.exe 即可。<br><img src="/pic/u2022080104.png" alt="img"><br>再一次，U++ 是自包含的，不会在upp目录之外写入任何内容。启动theide.exe后，您应该会看到与 Linux 基本相同的对话框：<br><img src="/pic/u2022080105.png" alt="img"></p>
<h2 id="苹果系统"><a href="#苹果系统" class="headerlink" title="苹果系统"></a>苹果系统</h2><p>在 MacOS 中，TheIDE 在存档中预编译，但是 U++ 需要 C++ 工具链来构建应用程序。您可以在此处找到有关如何安装工具链的说明，例如。</p>
<p>可以使用homebrew安装其他一些工具和库。建议使用以下软件包（因为在某些情况下可能需要它们）：openssl, libssh2.</p>
<p>要启动 TheIDE，您只需从解压缩的存档中启动theide.app：<br><img src="/pic/u2022080106.png" alt="img"><br>您现在应该看到与其他平台上基本相同的对话框：<br><img src="/pic/u2022080107.png" alt="img"></p>
<h2 id="选择主包对话框"><a href="#选择主包对话框" class="headerlink" title="选择主包对话框"></a>选择主包对话框</h2><p>无需赘述，我们现在将描述您在对话框中看到的内容。</p>
<p>程序集基本上是用于查找源代码模块的目录列表。此类模块的术语是package。包基本上是一个目录，其中包含 C++ 源文件和一些描述如何编译包和对其他包的依赖关系的元信息。</p>
<p>您在对话框中看到的程序集列表是可编辑的，但在您第一次启动 TheIDE 后，它会根据发行版附带的源创建一组预定义的程序集。在这里，examples主要包含更复杂的演示示例来“展示 U++ 的力量”（以及一些猫图片），同时reference包含近 200 个演示 U++ 框架各个方面的示例。tutorial是 U++ 网站上的几个多步骤教程附带的示例。uppsrc是包含基本 U++ 库和实用程序以及 TheIDE 本身的源代码的程序集。MyApps是为您使用 U++ 进行初始实验而准备的程序集。</p>
<p>除了“规范”模块外，U++ 版本还带有大量社区贡献的内容，称为bazaar. 目前，集市代码的质量和实用性差异很大，因此请谨慎使用。是这些包的演示示例，而您的项目是否已准备好包含包的程序集。 examples-bazaarMyApps-bazaarbazaar</p>
<h2 id="尝试第一个示例"><a href="#尝试第一个示例" class="headerlink" title="尝试第一个示例"></a>尝试第一个示例</h2><p>现在让我们加载、编译和运行其中一个示例。选择examples并在包列表中选择Days（当然，您可以选择任何其他示例，但Days以下屏幕截图所示）。TheIDE 将加载项目，您应该会看到：<br><img src="/pic/u2022080108.png" alt="img"><br>在左上角，有一个包列表。Days是您选择的包（它是主包），列出的其他包是它的直接或间接依赖项。在该列表区域下是当前选定包的文件列表。请注意，这意味着 U++ 项目的所有源文件，包括 U++ 框架的所有源文件，通常只需单击 2 次鼠标即可（实际上您必须小心不要通过编辑它们来损坏框架文件）。</p>
<p>窗口的中心显然包含当前文件的源代码。右边是一个叫做“导航器”的东西——这是一个基于C++源代码分析整个项目的搜索工具。</p>
<p>要编译并运行项目，请按Ctrl+F5或在Debug菜单中选择“ Execute ” 。<br><img src="/pic/u2022080109.png" alt="img"><br>整个项目现在将编译并启动应用程序。<br><img src="/pic/u2022080110.png" alt="img"><br>注意：第一次这样做时，对于给定的配置，U++ 将需要编译整个框架，因此预计最多需要一分钟才能完成。仅对主包进行更改后的下一次编译应该会快得多。</p>
<h2 id="将-TheIDE-安装到-Linux-桌面菜单中"><a href="#将-TheIDE-安装到-Linux-桌面菜单中" class="headerlink" title="将 TheIDE 安装到 Linux 桌面菜单中"></a>将 TheIDE 安装到 Linux 桌面菜单中</h2><p>本部分仅适用于 Linux。现在运行 TheIDE，现在是通过调用此菜单项将其安装到桌面菜单的好时机：<br><img src="/pic/u2022080111.png" alt="img"><br>这将创建 ~&#x2F; .local&#x2F;share&#x2F;applications&#x2F;theide.desktop文件，该文件应将 TheIDE 带入Linux 桌面的Programming子菜单。</p>
<h2 id="如何启动新项目"><a href="#如何启动新项目" class="headerlink" title="如何启动新项目"></a>如何启动新项目</h2><p>要开始编写自己的代码，您应该选择MyApps程序集，它被重新配置为将您新创建的包放入MyApps目录。<br><img src="/pic/u2022080112.png" alt="img"><br>现在按下“新建包”按钮，您将进入“创建新包”小向导。<br><img src="/pic/u2022080113.png" alt="img"><br>对于这个测试，我们将选择U++ Basic CtrlLib 应用程序，这基本上意味着没有主窗口类的预生成代码的 GUI 应用程序。所以它只是向我们的主包添加了正确的依赖项，并提供了非常少的样板代码。为了结束讲座，我们现在要做的就是插入：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PromptOK</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>进入GUI_APP_MAIN区块：<br><img src="/pic/u2022080114.png" alt="img"><br>Execute并像Days示例一样调用“ ”：<br><img src="/pic/u2022080115.png" alt="img"><br>恭喜，您刚刚编译了您的第一个 U++ 应用程序！</p>
<h2 id="UppHub"><a href="#UppHub" class="headerlink" title="UppHub"></a>UppHub</h2><p>U++ 2021.1 的新特性是UppHub，该系统允许将 3rd 方模块（库）与 U++ 项目轻松集成。这类似于包管理系统，如 PyPI（用于 Python）、NuGet（用于 C#）或 vcpkg（用于 C&#x2F;C++）。由于现有的 U++ 模块化系统，在 TheIDE 中的集成非常无缝。</p>
<p>通过包选择对话框中的按钮访问 UppHub 对话框<br><img src="/pic/u2022080116.png" alt="img"><br>或通过菜单项 Setup &#x2F; UppHub..<br><img src="/pic/u2022080117.png" alt="img"><br>安装按钮将源存储库克隆到对 U++ 包系统可见的位置，从而可以立即在项目中使用已安装的包。在此处查看完整的 UppHub 文档。</p>
<h2 id="接下来是什么"><a href="#接下来是什么" class="headerlink" title="接下来是什么"></a>接下来是什么</h2><p>如果您一直关注到这里，那么您可能会对 U++ 稍微感兴趣并想知道下一步该做什么。好吧，更熟悉 U++ 的推荐路径是检查并尝试参考示例：<br><img src="/pic/u2022080118.png" alt="img"></p>
<p>这些是小代码片段，展示了 U++ 框架的大多数方面，因为它们打算被使用。只需浏览列表，加载您感兴趣的内容并运行它。当然，还有一个包含文档、教程和论坛的网站，人们渴望用 U++ 解决您的所有问题。</p>
<h2 id="有用的链接"><a href="#有用的链接" class="headerlink" title="有用的链接"></a>有用的链接</h2><p>U++主页<br><a href="http://www.ultimatepp.org/">http://www.ultimatepp.org/</a><br>U++下载页面<br><a href="https://sourceforge.net/projects/upp/files/upp/2022.2/">https://sourceforge.net/projects/upp/files/upp/2022.2/</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>U++</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL Index Manager – 用于 SQL Server 和 Azure 上的索引维护的免费 G​​UI 工具</title>
    <url>/8193.html</url>
    <content><![CDATA[<p>适用于 SQL Server 和 Azure 的开源索引维护工具<br>本文评估了我针对 SQL Server 和 Azure 的免费索引维护工具的设计方法：SQL 索引管理器。文章分析了 RedGate SQL Index Manager (v1.1.9.1378) 和 DevArt - dbForge Index Manager for SQL Server (v1.10.38) 的方法，并探讨了为什么我的工具将扫描分为两部分。最初，一个大的请求通过过滤那些不包含在过滤范围内的分区来预先确定分区的大小，然后，我们只获取那些包含数据的分区，以避免对空索引进行不必要的读取。</p>
<p><a href="https://www.codeproject.com/KB/Articles/5162340/SQLIndexManager.zip">Download SQL Index Manager v1.0.0.69 </a>(latest)</p>
<p><a href="https://www.codeproject.com/KB/Articles/5162340/SQLIndexManagerSource_v1.0.0.68.zip">Download source code</a> - 16.3 MB</p>
<p><a href="https://www.codeproject.com/KB/Articles/5162340/SQLIndexManager_v1.0.0.68.zip">Download SQL Index Manager v1.0.0.68</a> - 16.2 MB</p>
<p><a href="https://www.codeproject.com/KB/Articles/5162340/SQLIndexManager_v1.0.0.67.zip">Download SQL Index Manager v1.0.0.67</a> - 16.2 MB</p>
<p>介绍<br>作为一名 SQL Server DBA，我已经工作了 8 年多，负责管理和优化服务器的性能。在我的空闲时间，我想为宇宙和我的同事做一些有用的事情。这就是我们最终获得用于 SQL Server 和 Azure的免费索引维护工具的方式。</p>
<p>主意<br>每隔一段时间，人们在处理他们的优先事项时，就会像一个手指型电池——一次激励性的充电只持续一次闪光，然后一切都消失了。直到最近，我在这个生命观察中也不例外。我经常被创造自己的东西的想法所困扰，但是优先级从一个到另一个，什么都没有完成。</p>
<p>DevArt 开发了用于开发和管理 SQL Server、MySQL 和 Oracle 数据库的软件，对我的动力和职业发展产生了重大影响。</p>
<p>在来找他们之前，我对创建自己的产品的具体细节知之甚少，但在这个过程中，我获得了很多关于 SQL Server 内部结构的知识。一年多以来，一直在他们的产品线中进行查询优化，我逐渐开始了解市场上哪个功能比另一个更需要。</p>
<p>到了某个阶段，我就有了做一个新的小众产品的想法，但由于某些情况，这个想法没有成功。那个时候，基本没能在公司内部找到足够的资源，在不影响核心业务的情况下进行新项目。</p>
<p>在一个全新的地方工作并尝试自己创建一个项目让我不断妥协。最初的想法是制作一个花里胡哨的大产品，很快就停止了，并逐渐转变为一个不同的方向——将计划的功能分解为单独的迷你工具，并相互独立地实现它们。</p>
<p>于是，<a href="https://github.com/sergeysyrovatchenko/SQLIndexManager">SQL 索引管理器</a>诞生了，它是 SQL Server 和 Azure 的免费索引维护工具。主要想法是以 RedGate 和 Devart 公司的商业替代品为基础，并尝试在我自己的项目中改进其功能。</p>
<p><img src="/pic/sql2022080201.png" alt="img"><br><img src="/pic/sql2022080202.png" alt="img"></p>
<p>执行<br>从口头上讲，一切听起来都很简单……只需观看一些激励视频，打开“Rocky Balboa”模式，然后开始制作很酷的产品。但是让我们面对音乐，一切都不是那么美好，因为在使用系统表功能时有很多陷阱，sys.dm_db_index_physical_stats同时，它是唯一可以从中获取有关索引碎片的最新信息的地方.</p>
<p>从开发的最初几天开始，就有一个很好的机会在标准方案中创造一种沉闷的方式，并复制竞争应用程序已经调试过的逻辑，同时添加一些即兴发挥。但是在分析元数据查询之后，我想做一些更优化的事情，由于大公司的官僚主义，这些东西永远不会出现在他们的产品中。</p>
<p>在分析<a href="https://www.red-gate.com/products/dba/sql-index-manager/">RedGate SQL 索引管理器</a>（v1.1.9.1378 - 每个用户 155 美元）时，您可以看到应用程序使用了一种非常简单的方法：使用第一个查询，我们得到一个用户表和视图的列表，然后在第二个查询之后一，我们返回所选数据库中所有索引的列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT objects.name AS tableOrViewName</span><br><span class="line">     , objects.object_id AS tableOrViewId</span><br><span class="line">     , schemas.name AS schemaName</span><br><span class="line">     , CAST(ISNULL(lobs.NumLobs, 0) AS BIT) AS ContainsLobs</span><br><span class="line">     , o.is_memory_optimized</span><br><span class="line">FROM sys.objects AS objects</span><br><span class="line">JOIN sys.schemas AS schemas ON schemas.schema_id = objects.schema_id</span><br><span class="line">LEFT JOIN (</span><br><span class="line">    SELECT object_id</span><br><span class="line">         , COUNT(*) AS NumLobs</span><br><span class="line">    FROM sys.columns WITH (NOLOCK)</span><br><span class="line">    WHERE system_type_id IN (34, 35, 99)</span><br><span class="line">        OR max_length = -1</span><br><span class="line">    GROUP BY object_id</span><br><span class="line">) AS lobs ON objects.object_id = lobs.object_id</span><br><span class="line">LEFT JOIN sys.tables AS o ON o.object_id = objects.object_id</span><br><span class="line">WHERE objects.type = &#x27;U&#x27;</span><br><span class="line">    OR objects.type = &#x27;V&#x27;</span><br><span class="line"></span><br><span class="line">SELECT i.object_id AS tableOrViewId</span><br><span class="line">     , i.name AS indexName</span><br><span class="line">     , i.index_id AS indexId</span><br><span class="line">     , i.allow_page_locks AS allowPageLocks</span><br><span class="line">     , p.partition_number AS partitionNumber</span><br><span class="line">     , CAST((c.numPartitions - 1) AS BIT) AS belongsToPartitionedIndex</span><br><span class="line">FROM sys.indexes AS i</span><br><span class="line">JOIN sys.partitions AS p ON p.index_id = i.index_id</span><br><span class="line">                        AND p.object_id = i.object_id</span><br><span class="line">JOIN (</span><br><span class="line">    SELECT COUNT(*) AS numPartitions</span><br><span class="line">         , object_id</span><br><span class="line">         , index_id</span><br><span class="line">    FROM sys.partitions</span><br><span class="line">    GROUP BY object_id</span><br><span class="line">           , index_id</span><br><span class="line">) AS c ON c.index_id = i.index_id</span><br><span class="line">      AND c.object_id = i.object_id</span><br><span class="line">WHERE i.index_id &gt; 0 -- ignore heaps</span><br><span class="line">    AND i.is_disabled = 0</span><br><span class="line">    AND i.is_hypothetical = 0</span><br></pre></td></tr></table></figure>
<p>接下来，在while每个索引分区的循环中，发送一个请求以确定其大小和碎片级别。在扫描结束时，重量小于条目阈值的索引会显示在客户端上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXEC sp_executesql N&#x27;</span><br><span class="line">SELECT index_id, avg_fragmentation_in_percent, page_count</span><br><span class="line">FROM sys.dm_db_index_physical_stats(@databaseId, @objectId, @indexId, @partitionNr, NULL)&#x27;</span><br><span class="line">    , N&#x27;@databaseId int,@objectId int,@indexId int,@partitionNr int&#x27;</span><br><span class="line">    , @databaseId = 7, @objectId = 2133582639, @indexId = 1, @partitionNr = 1</span><br><span class="line"></span><br><span class="line">EXEC sp_executesql N&#x27;</span><br><span class="line">SELECT index_id, avg_fragmentation_in_percent, page_count</span><br><span class="line">FROM sys.dm_db_index_physical_stats(@databaseId, @objectId, @indexId, @partitionNr, NULL)&#x27;</span><br><span class="line">    , N&#x27;@databaseId int,@objectId int,@indexId int,@partitionNr int&#x27;</span><br><span class="line">    , @databaseId = 7, @objectId = 2133582639, @indexId = 2, @partitionNr = 1</span><br><span class="line"></span><br><span class="line">EXEC sp_executesql N&#x27;</span><br><span class="line">SELECT index_id, avg_fragmentation_in_percent, page_count</span><br><span class="line">FROM sys.dm_db_index_physical_stats(@databaseId, @objectId, @indexId, @partitionNr, NULL)&#x27;</span><br><span class="line">    , N&#x27;@databaseId int,@objectId int,@indexId int,@partitionNr int&#x27;</span><br><span class="line">    , @databaseId = 7, @objectId = 2133582639, @indexId = 3, @partitionNr = 1</span><br></pre></td></tr></table></figure>
<p>在分析此应用程序的逻辑时，您可能会发现各种缺点。例如，在发送请求之前，不会检查当前分区是否包含任何行以将空分区排除在扫描之外。</p>
<p>但问题在另一个方面表现得更加明显——对服务器的请求数将大约等于从sys.partitions. 鉴于真实数据库可能包含数万个分区，这种细微差别可能会导致向服务器发送大量类似请求。在数据库位于远程服务器的情况下，由于每个请求的执行增加了网络延迟，即使是最简单的请求，扫描时间也会更长。</p>
<p><a href="https://www.devart.com/dbforge/sql/index-manager/">与 RedGate 不同的是，由 DevArt 开发的用于 SQL Server</a>的类似产品dbForge Index Manager （v1.10.38 - 每用户 99 美元）在一个大型查询中接收信息，然后在客户端上显示所有内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT SCHEMA_NAME(o.[schema_id]) AS [schema_name]</span><br><span class="line">     , o.name AS parent_name</span><br><span class="line">     , o.[type] AS parent_type</span><br><span class="line">     , i.name</span><br><span class="line">     , i.type_desc</span><br><span class="line">     , s.avg_fragmentation_in_percent</span><br><span class="line">     , s.page_count</span><br><span class="line">     , p.partition_number</span><br><span class="line">     , p.[rows]</span><br><span class="line">     , ISNULL(lob.is_lob_legacy, 0) AS is_lob_legacy</span><br><span class="line">     , ISNULL(lob.is_lob, 0) AS is_lob</span><br><span class="line">     , CASE WHEN ds.[type] = &#x27;PS&#x27; THEN 1 ELSE 0 END AS is_partitioned</span><br><span class="line">FROM sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, NULL) s</span><br><span class="line">JOIN sys.partitions p ON s.[object_id] = p.[object_id]</span><br><span class="line">                     AND s.index_id = p.index_id</span><br><span class="line">                     AND s.partition_number = p.partition_number</span><br><span class="line">JOIN sys.indexes i ON i.[object_id] = s.[object_id]</span><br><span class="line">                  AND i.index_id = s.index_id</span><br><span class="line">LEFT JOIN (</span><br><span class="line">    SELECT c.[object_id]</span><br><span class="line">         , index_id = ISNULL(i.index_id, 1)</span><br><span class="line">         , is_lob_legacy = MAX(CASE WHEN c.system_type_id IN (34, 35, 99) THEN 1 END)</span><br><span class="line">         , is_lob = MAX(CASE WHEN c.max_length = -1 THEN 1 END)</span><br><span class="line">    FROM sys.columns c</span><br><span class="line">    LEFT JOIN sys.index_columns i ON c.[object_id] = i.[object_id]</span><br><span class="line">                                 AND c.column_id = i.column_id</span><br><span class="line">                                 AND i.index_id &gt; 0</span><br><span class="line">    WHERE c.system_type_id IN (34, 35, 99)</span><br><span class="line">        OR c.max_length = -1</span><br><span class="line">    GROUP BY c.[object_id], i.index_id</span><br><span class="line">) lob ON lob.[object_id] = i.[object_id]</span><br><span class="line">     AND lob.index_id = i.index_id</span><br><span class="line">JOIN sys.objects o ON o.[object_id] = i.[object_id]</span><br><span class="line">JOIN sys.data_spaces ds ON i.data_space_id = ds.data_space_id</span><br><span class="line">WHERE i.[type] IN (1, 2)</span><br><span class="line">    AND i.is_disabled = 0</span><br><span class="line">    AND i.is_hypothetical = 0</span><br><span class="line">    AND s.index_level = 0</span><br><span class="line">    AND s.alloc_unit_type_desc = &#x27;IN_ROW_DATA&#x27;</span><br><span class="line">    AND o.[type] IN (&#x27;U&#x27;, &#x27;V&#x27;)</span><br></pre></td></tr></table></figure>

<p>消除了竞争产品中类似请求的面纱的主要问题，但这种实现的缺点是没有额外的参数传递给sys.dm_db_index_physical_stats可以限制扫描明显不必要的索引的函数。事实上，这会导致在扫描阶段获取系统中所有索引的信息以及不必要的磁盘负载。</p>
<p>值得一提的是，从中获取的数据sys.dm_db_index_physical_stats不会永久缓存在缓冲池中，因此在获取有关索引碎片的信息时最小化物理读取是我的应用程序开发过程中的优先任务之一。</p>
<p>经过多次实验，我设法通过将扫描分为两部分来结合这两种方法。最初，一个大请求通过过滤那些不包括在过滤范围内的分区来预先确定分区的大小：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO #AllocationUnits (ContainerID, ReservedPages, UsedPages)</span><br><span class="line">SELECT [container_id]</span><br><span class="line">     , SUM([total_pages])</span><br><span class="line">     , SUM([used_pages])</span><br><span class="line">FROM sys.allocation_units WITH(NOLOCK)</span><br><span class="line">GROUP BY [container_id]</span><br><span class="line">HAVING SUM([total_pages]) BETWEEN @MinIndexSize AND @MaxIndexSize</span><br></pre></td></tr></table></figure>
<p>接下来，我们只获取那些包含数据的分区，以避免对空索引进行不必要的读取。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT [object_id]</span><br><span class="line">     , [index_id]</span><br><span class="line">     , [partition_id]</span><br><span class="line">     , [partition_number]</span><br><span class="line">     , [rows]</span><br><span class="line">     , [data_compression]</span><br><span class="line">INTO #Partitions</span><br><span class="line">FROM sys.partitions WITH(NOLOCK)</span><br><span class="line">WHERE [object_id] &gt; 255</span><br><span class="line">    AND [rows] &gt; 0</span><br><span class="line">    AND [object_id] NOT IN (SELECT * FROM #ExcludeList)</span><br></pre></td></tr></table></figure>
<p>根据设置，仅获取用户想要分析的索引类型（支持使用堆、集群&#x2F;非集群索引和列存储）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO #Indexes</span><br><span class="line">SELECT ObjectID         = i.[object_id]</span><br><span class="line">     , IndexID          = i.index_id</span><br><span class="line">     , IndexName        = i.[name]</span><br><span class="line">     , PagesCount       = a.ReservedPages</span><br><span class="line">     , UnusedPagesCount = a.ReservedPages - a.UsedPages</span><br><span class="line">     , PartitionNumber  = p.[partition_number]</span><br><span class="line">     , RowsCount        = ISNULL(p.[rows], 0)</span><br><span class="line">     , IndexType        = i.[type]</span><br><span class="line">     , IsAllowPageLocks = i.[allow_page_locks]</span><br><span class="line">     , DataSpaceID      = i.[data_space_id]</span><br><span class="line">     , DataCompression  = p.[data_compression]</span><br><span class="line">     , IsUnique         = i.[is_unique]</span><br><span class="line">     , IsPK             = i.[is_primary_key]</span><br><span class="line">     , FillFactorValue  = i.[fill_factor]</span><br><span class="line">     , IsFiltered       = i.[has_filter]</span><br><span class="line">FROM #AllocationUnits a</span><br><span class="line">JOIN #Partitions p ON a.ContainerID = p.[partition_id]</span><br><span class="line">JOIN sys.indexes i WITH(NOLOCK) ON i.[object_id] = p.[object_id]</span><br><span class="line"></span><br><span class="line">                               AND p.[index_id] = i.[index_id]</span><br><span class="line">WHERE i.[type] IN (0, 1, 2, 5, 6)</span><br><span class="line">    AND i.[object_id] &gt; 255</span><br></pre></td></tr></table></figure>
<p>之后，我们添加了一点魔法，并且……对于所有小索引，我们通过重复调用函数sys.dm_db_index_physical_stats并完整指示所有参数来确定碎片级别。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO #Fragmentation (ObjectID, IndexID, PartitionNumber, Fragmentation)</span><br><span class="line">SELECT i.ObjectID</span><br><span class="line">     , i.IndexID</span><br><span class="line">     , i.PartitionNumber</span><br><span class="line">     , r.[avg_fragmentation_in_percent]</span><br><span class="line">FROM #Indexes i</span><br><span class="line">CROSS APPLY sys.dm_db_index_physical_stats_</span><br><span class="line">    (@DBID, i.ObjectID, i.IndexID, i.PartitionNumber, &#x27;LIMITED&#x27;) r</span><br><span class="line">WHERE i.PagesCount &lt;= @PreDescribeSize</span><br><span class="line">    AND r.[index_level] = 0</span><br><span class="line">    AND r.[alloc_unit_type_desc] = &#x27;IN_ROW_DATA&#x27;</span><br><span class="line">    AND i.IndexType IN (0, 1, 2)</span><br></pre></td></tr></table></figure>
<p>接下来，我们通过过滤掉多余的数据，将所有可能的信息返回给客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT i.ObjectID</span><br><span class="line">     , i.IndexID</span><br><span class="line">     , i.IndexName</span><br><span class="line">     , ObjectName       = o.[name]</span><br><span class="line">     , SchemaName       = s.[name]</span><br><span class="line">     , i.PagesCount</span><br><span class="line">     , i.UnusedPagesCount</span><br><span class="line">     , i.PartitionNumber</span><br><span class="line">     , i.RowsCount</span><br><span class="line">     , i.IndexType</span><br><span class="line">     , i.IsAllowPageLocks</span><br><span class="line">     , u.TotalWrites</span><br><span class="line">     , u.TotalReads</span><br><span class="line">     , u.TotalSeeks</span><br><span class="line">     , u.TotalScans</span><br><span class="line">     , u.TotalLookups</span><br><span class="line">     , u.LastUsage</span><br><span class="line">     , i.DataCompression</span><br><span class="line">     , f.Fragmentation</span><br><span class="line">     , IndexStats       = STATS_DATE(i.ObjectID, i.IndexID)</span><br><span class="line">     , IsLobLegacy      = ISNULL(lob.IsLobLegacy, 0)</span><br><span class="line">     , IsLob            = ISNULL(lob.IsLob, 0)</span><br><span class="line">     , IsSparse         = CAST(CASE WHEN p.ObjectID IS NULL THEN 0 ELSE 1 END AS BIT)</span><br><span class="line">     , IsPartitioned    = CAST(CASE WHEN dds.[data_space_id] _</span><br><span class="line">                          IS NOT NULL THEN 1 ELSE 0 END AS BIT)</span><br><span class="line">     , FileGroupName    = fg.[name]</span><br><span class="line">     , i.IsUnique</span><br><span class="line">     , i.IsPK</span><br><span class="line">     , i.FillFactorValue</span><br><span class="line">     , i.IsFiltered</span><br><span class="line">     , a.IndexColumns</span><br><span class="line">     , a.IncludedColumns</span><br><span class="line">FROM #Indexes i</span><br><span class="line">JOIN sys.objects o WITH(NOLOCK) ON o.[object_id] = i.ObjectID</span><br><span class="line">JOIN sys.schemas s WITH(NOLOCK) ON s.[schema_id] = o.[schema_id]</span><br><span class="line">LEFT JOIN #AggColumns a ON a.ObjectID = i.ObjectID</span><br><span class="line">                       AND a.IndexID = i.IndexID</span><br><span class="line">LEFT JOIN #Sparse p ON p.ObjectID = i.ObjectID</span><br><span class="line">LEFT JOIN #Fragmentation f ON f.ObjectID = i.ObjectID</span><br><span class="line">                          AND f.IndexID = i.IndexID</span><br><span class="line">                          AND f.PartitionNumber = i.PartitionNumber</span><br><span class="line">LEFT JOIN (</span><br><span class="line">    SELECT ObjectID      = [object_id]</span><br><span class="line">         , IndexID       = [index_id]</span><br><span class="line">         , TotalWrites   = NULLIF([user_updates], 0)</span><br><span class="line">         , TotalReads    = NULLIF([user_seeks] + [user_scans] + [user_lookups], 0)</span><br><span class="line">         , TotalSeeks    = NULLIF([user_seeks], 0)</span><br><span class="line">         , TotalScans    = NULLIF([user_scans], 0)</span><br><span class="line">         , TotalLookups  = NULLIF([user_lookups], 0)</span><br><span class="line">         , LastUsage     = (</span><br><span class="line">                                SELECT MAX(dt)</span><br><span class="line">                                FROM (</span><br><span class="line">                                    VALUES ([last_user_seek])</span><br><span class="line">                                         , ([last_user_scan])</span><br><span class="line">                                         , ([last_user_lookup])</span><br><span class="line">                                         , ([last_user_update])</span><br><span class="line">                                ) t(dt)</span><br><span class="line">                           )</span><br><span class="line">    FROM sys.dm_db_index_usage_stats WITH(NOLOCK)</span><br><span class="line">    WHERE [database_id] = @DBID</span><br><span class="line">) u ON i.ObjectID = u.ObjectID</span><br><span class="line">   AND i.IndexID = u.IndexID</span><br><span class="line">LEFT JOIN #Lob lob ON lob.ObjectID = i.ObjectID</span><br><span class="line">                  AND lob.IndexID = i.IndexID</span><br><span class="line">LEFT JOIN sys.destination_data_spaces dds WITH(NOLOCK) _</span><br><span class="line">            ON i.DataSpaceID = dds.[partition_scheme_id]</span><br><span class="line">            AND i.PartitionNumber = dds.[destination_id]</span><br><span class="line">JOIN sys.filegroups fg WITH(NOLOCK) _</span><br><span class="line">            ON ISNULL(dds.[data_space_id], i.DataSpaceID) = fg.[data_space_id]</span><br><span class="line">WHERE o.[type] IN (&#x27;V&#x27;, &#x27;U&#x27;)</span><br><span class="line">    AND (</span><br><span class="line">            f.Fragmentation &gt;= @Fragmentation</span><br><span class="line">        OR</span><br><span class="line">            i.PagesCount &gt; @PreDescribeSize</span><br><span class="line">        OR</span><br><span class="line">            i.IndexType IN (5, 6)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>之后，点请求确定大型索引的碎片级别。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXEC sp_executesql N&#x27;</span><br><span class="line">DECLARE @DBID INT = DB_ID()</span><br><span class="line">SELECT [avg_fragmentation_in_percent]</span><br><span class="line">FROM sys.dm_db_index_physical_stats(@DBID, @ObjectID, @IndexID, @PartitionNumber, &#x27;&#x27;LIMITED&#x27;&#x27;)</span><br><span class="line">WHERE [index_level] = 0</span><br><span class="line">    AND [alloc_unit_type_desc] = &#x27;&#x27;IN_ROW_DATA&#x27;&#x27;&#x27;</span><br><span class="line">    , N&#x27;@ObjectID int,@IndexID int,@PartitionNumber int&#x27;</span><br><span class="line">    , @ObjectId = 1044198770, @IndexId = 1, @PartitionNumber = 1</span><br><span class="line"></span><br><span class="line">EXEC sp_executesql N&#x27;</span><br><span class="line">DECLARE @DBID INT = DB_ID()</span><br><span class="line">SELECT [avg_fragmentation_in_percent]</span><br><span class="line">FROM sys.dm_db_index_physical_stats(@DBID, @ObjectID, @IndexID, @PartitionNumber, &#x27;&#x27;LIMITED&#x27;&#x27;)</span><br><span class="line">WHERE [index_level] = 0</span><br><span class="line">    AND [alloc_unit_type_desc] = &#x27;&#x27;IN_ROW_DATA&#x27;&#x27;&#x27;</span><br><span class="line">    , N&#x27;@ObjectID int,@IndexID int,@PartitionNumber int&#x27;</span><br><span class="line">    , @ObjectId = 1552724584, @IndexId = 0, @PartitionNumber = 1</span><br></pre></td></tr></table></figure>
<p>由于这种方法，在生成请求时，我设法解决了竞争对手应用程序中遇到的扫描性能问题。本来可以到此为止，但在开发的过程中，各种新的想法逐渐涌现，让我的产品应用范围的扩大成为可能。</p>
<p>最初，WAIT_AT_LOW_PRIORITY实现了对使用的支持，然后可以使用DATA_COMPRESSION和FILL_FACTOR重建索引。</p>
<p><img src="/pic/sql2022080203.png" alt="img"><br>该应用程序已经“散布”了以前计划外的功能，例如维护列存储：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM (</span><br><span class="line">    SELECT IndexID          = [index_id]</span><br><span class="line">         , PartitionNumber  = [partition_number]</span><br><span class="line">         , PagesCount       = SUM([size_in_bytes]) / 8192</span><br><span class="line">         , UnusedPagesCount = ISNULL(SUM(CASE WHEN [state] = 1 _</span><br><span class="line">                              THEN [size_in_bytes] END), 0) / 8192</span><br><span class="line">         , Fragmentation    = CAST(ISNULL(SUM(CASE WHEN [state] = 1 _</span><br><span class="line">                              THEN [size_in_bytes] END), 0)</span><br><span class="line">                            * 100. / SUM([size_in_bytes]) AS FLOAT)</span><br><span class="line">    FROM sys.fn_column_store_row_groups(@ObjectID)</span><br><span class="line">    GROUP BY [index_id]</span><br><span class="line">           , [partition_number]</span><br><span class="line">) t</span><br><span class="line">WHERE Fragmentation &gt;= @Fragmentation</span><br><span class="line">    AND PagesCount BETWEEN @MinIndexSize AND @MaxIndexSize</span><br></pre></td></tr></table></figure>

<p>或者基于以下信息创建非聚集索引的能力dm_db_missing_index：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ObjectID     = d.[object_id]</span><br><span class="line">     , UserImpact   = gs.[avg_user_impact]</span><br><span class="line">     , TotalReads   = gs.[user_seeks] + gs.[user_scans]</span><br><span class="line">     , TotalSeeks   = gs.[user_seeks]</span><br><span class="line">     , TotalScans   = gs.[user_scans]</span><br><span class="line">     , LastUsage    = ISNULL(gs.[last_user_scan], gs.[last_user_seek])</span><br><span class="line">     , IndexColumns =</span><br><span class="line">                CASE</span><br><span class="line">                    WHEN d.[equality_columns] IS NOT NULL </span><br><span class="line">                                _AND d.[inequality_columns] IS NOT NULL</span><br><span class="line">                        THEN d.[equality_columns] + &#x27;, &#x27; + d.[inequality_columns]</span><br><span class="line">                    WHEN d.[equality_columns] IS NOT NULL AND d.[inequality_columns] IS NULL</span><br><span class="line">                        THEN d.[equality_columns]</span><br><span class="line">                    ELSE d.[inequality_columns]</span><br><span class="line">                END</span><br><span class="line">     , IncludedColumns = d.[included_columns]</span><br><span class="line">FROM sys.dm_db_missing_index_groups g WITH(NOLOCK)</span><br><span class="line">JOIN sys.dm_db_missing_index_group_stats gs WITH(NOLOCK) _</span><br><span class="line">                       ON gs.[group_handle] = g.[index_group_handle]</span><br><span class="line">JOIN sys.dm_db_missing_index_details d WITH(NOLOCK) _</span><br><span class="line">                       ON g.[index_handle] = d.[index_handle]</span><br><span class="line">WHERE d.[database_id] = DB_ID()</span><br></pre></td></tr></table></figure>
<p>结果和计划<br>关键是开发计划并没有就此结束，因为我渴望进一步开发这个应用程序。下一步是添加用于查找重复 ( done ) 或未使用索引 ( done ) 的功能，以及在 SQL Server中实现对维护统计信息 ( done ) 的完全支持。</p>
<p>现在市场上有很多付费解决方案。我想相信，由于自由定位、更优化的查询以及对某人有用的各种 gismos 的可用性，该产品肯定会在日常任务中变得有用。</p>
<p>该应用程序的最新版本可以在GitHub 上下载。来源在同一个地方。</p>
<p>我期待任何反馈。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Sql</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown表格语法</title>
    <url>/50630.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>单元格</td>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">居中对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>解决hexo本地与github部署不一致的问题</title>
    <url>/36684.html</url>
    <content><![CDATA[<p>先通过右击-检查，查看console(控制台)<br>查看是哪里出错了，比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Uncaught ReferenceError: NexT is not defined     at utils.js:9:1</span><br></pre></td></tr></table></figure>
<p>一看，utils.js和main.js用的是之前主题的。<br>不知道为什么public目录里的这两个js没有更新。</p>
<p>解决方案：<br>从butterfly主题目录\source\js<br>复制这两个js文件到public对应目录。</p>
<p>然后重新上传。<br>hexo d</p>
<p>或者把public目录里面的内容全部删除，再重新生成一遍。<br>hexo g</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>rxcg：用于物联网的简单文本匹配器 C 代码生成器</title>
    <url>/34284.html</url>
    <content><![CDATA[<p>根据正则表达式生成紧密的 C 代码以匹配文本。<br>创建一个包含正则表达式的文件，将其提供给该工具，然后就可以了！- 您拥有即时、无依赖的 C 代码，可用于匹配来自任何输入流的所述表达式。<br><a href="https://github.com/codewitch-honey-crisis/rxcg">从 GitHub 下载最新版本</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((byte &amp; <span class="number">248</span>) ==<span class="number">240</span>)&#123;</span><br><span class="line">    Cp=((<span class="type">uint32_t</span>) i &amp;~<span class="number">248</span>)&lt;&lt;<span class="number">18</span>|</span><br><span class="line">        ((<span class="type">uint32_t</span>) fgetc(h) &amp; ~<span class="number">192</span>)&lt;&lt;<span class="number">12</span> |</span><br><span class="line">        ((<span class="type">uint32_t</span>) fgetc(h) &amp; ~<span class="number">192</span>)&lt;&lt;<span class="number">6</span> |</span><br><span class="line">        ((<span class="type">uint32_t</span>) fgetc(h) &amp; ~<span class="number">192</span>);</span><br><span class="line">    *out_advance = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>介绍<br>我已经为他们编写了很多正则表达式引擎和代码生成器，这在这一点上几乎是本能的。我这样做是为了好玩。这次我这样做是因为它很有用。</p>
<p>我需要从基于 REST 的 Web 服务获得的 JSON 结果中窃取一个字段。我需要通过一个小型物联网设备来完成，当我只需要一个重要但很小的数据时，我不想在整个 JSON 库上浪费宝贵的程序空间。</p>
<p>我真正需要的是正则表达式，但我也不想在正则表达式引擎上浪费空间。</p>
<p>最后，这意味着代码生成器将在给定输入正则表达式的情况下生成匹配器代码。使用这样的动物，我可以获得正则表达式功能，但足以完成这项工作，最终结果中不包含任何非绝对必要的内容。我们没有将正则表达式提供给正则表达式引擎以在运行时进行处理和解释，而是将代码煮熟以匹配硬编码的正则表达式，并且实际上不必在运行时进行解释。</p>
<p>了解这个烂摊子<br>rxcg 是一个表格驱动的 DFA&#x2F;非回溯代码生成器。这会生成运行O(n)复杂的代码，其中n 输入字符串的长度是多少。总的来说，这意味着当它在流中从左向右移动时，它只访问一次。</p>
<p>这也意味着它使用数组&#x2F;数据表来驱动匹配而不是硬编码goto。这以一些速度（在某些情况下）换取大小，因为基于阵列的技术呈现更小的闪存占用空间，但运行速度可能不如goto基于编排的绝对快。</p>
<p>这是一个简洁的设置，以保持最终代码的简单和高效。它不支持子捕获组。您可以分组，但这只会改变运算符的优先级。它不会子捕获到一个组中。它不支持诸如^ or之类的锚点$。它确实 支持 Unicode，一直到 UTF-32，以及常见的字符类，包括 Unicode 的 likeIsLetter和IsDigit.</p>
<p>为了灵活性，它使用回调来检索输入流中的下一个 UTF-32 代码点。您负责实现回调函数来检索您的数据，无论是来自文件、字符串还是网络。这也意味着将您的流转换为 UTF-32 代码点是您的工作，无论如何都可以。幸运的是，我在示例中包含了可以从 UTF-8 或 ASCII 文件或字符串执行此操作的代码。</p>
<p>输入文件为 Reggie&#x2F;Rolex 文件格式。</p>
<p>它是一种基于行的格式，其中每一行的形成类似于以下行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CIdent&lt;ignoreCase&gt;= <span class="string">&#x27;[A-Z_][0-9A-Z_]*&#x27;</span></span><br></pre></td></tr></table></figure>

<p>或更一般地作为 EBNF：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">identifier [ &quot;&lt;&quot; attributes &quot;&gt;&quot; ] &quot;=&quot; ( &quot;&#x27;&quot; regexp &quot;&#x27;&quot; | &quot;\&quot;&quot; literal &quot;\&quot;&quot; )</span><br></pre></td></tr></table></figure>
<p>每个属性都是一个标识符，后跟一个可选 &#x3D; 的 JSON 样式字符串、布尔值、整数或其他值。如果未指定该值，则上面的 true 含义 ignoreCase 设置为 true。请注意文字表达式是如何用双引号括起来的，而正则表达式是如何用单引号括起来的！</p>
<p>有几个可用的属性，如下所示：</p>
<p>ignoreCase - 表示表达式应该被解释为不区分大小写<br>blockEnd - 表示指定符号的多字符结束条件。遇到时，匹配器将继续读取，直到 blockEnd 找到该值，并使用它。这对于具有多个字符结尾条件的表达式很有用，例如 C 块注释、HTML&#x2F;SGML 注释和 XML CDATA 部分。如果是字符串，请记住使用双引号，如果blockEnd是正则表达式，请记住使用单引号。<br>正则表达式语言支持如上基本的非回溯构造和常用字符类，以及&#x2F;&#x2F;&#x2F; [:IsLetter:]等。映射到他们的 .NET 对应物。确保转义单引号，因为它们在文件中用于分隔表达式。[:IsLetterOrDigit:][:IsWhiteSpace:]</p>
<p>该工具是一个基于命令行的应用程序，它接受一个输入文件和一个可选&#x2F;size <capture_size> 参数，从中生成两个文件：Name.h 和 Name.c，其中Name 是输入文件的名称。对于 MyMatch.rl，该工具将生成 MyMatch.h 和 MyMatch.c。</p>
<p>该&#x2F;size参数指示捕获缓冲区的大小。匹配时，将返回匹配的文本代码点，但它们不能大于指示的大小，否则捕获将被剪裁。这可以是一个数值，也可以是一个#define’d 宏的名称，如CAPTURE_SIZE.</p>
<p>代码生成器本身是用 C# 编写的，并使用我的 FastFA 正则表达式引擎，我的另一个项目Reggie也使用了该引擎。事实上，我无耻地抄袭了大量用于该项目的代码，因此请访问该链接以了解详细信息。我本可以编写一个 Reggie 插件来做到这一点，但老实说，Reggie 在这方面有点笨拙，我想减少一些，特别是对于物联网，在物联网中做像词法分析这样的事情会适得其反。</p>
<p>编码这个混乱<br>使用生成的代码首先涉及进行回调。如果您只关心 7 位 ASCII 并且您通过将每个 ASCII 字符转换为 来作弊，这很容易int32_t，但是对于 Unicode 支持，您需要做一些实际的工作。</p>
<p>示例项目包括两个基本的回调实现——一个用于字符串，一个用于文件。在每种情况下，我们都需要跟踪输入以及我们在其中的位置，以便每次调用时都可以返回下一个字符，或者在到达结尾时返回-1。</p>
<p>这是字符串实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// holds the current string pointer</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">string_cb_state</span> &#123;</span><br><span class="line">    <span class="type">char</span>* sz;</span><br><span class="line">&#125; <span class="type">string_cb_state_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">string_callback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>* out_advance, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">void</span>* state)</span> </span>&#123;</span><br><span class="line">    <span class="type">string_cb_state_t</span>* ps = (<span class="type">string_cb_state_t</span>*)state;</span><br><span class="line">    <span class="type">int32_t</span> cp;</span><br><span class="line">    <span class="keyword">if</span> (!*ps-&gt;sz) &#123;</span><br><span class="line">        <span class="comment">// end of stream</span></span><br><span class="line">        *out_advance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// decode UTF-8 to UTF-32</span></span><br><span class="line">    <span class="type">uint8_t</span> byte = (<span class="type">uint8_t</span>)*ps-&gt;sz;</span><br><span class="line">    <span class="keyword">if</span> ((byte &amp; <span class="number">128</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        cp = ((<span class="type">uint32_t</span>) *ps-&gt;sz &amp; ~<span class="number">128</span>);</span><br><span class="line">        *out_advance = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((byte &amp; <span class="number">224</span>) == <span class="number">192</span>) &#123;</span><br><span class="line">        cp=((<span class="type">uint32_t</span>) ps-&gt;sz[<span class="number">0</span>] &amp; ~<span class="number">224</span>) &lt;&lt; <span class="number">6</span> |</span><br><span class="line">        ((<span class="type">uint32_t</span>) ps-&gt;sz[<span class="number">1</span>] &amp; ~<span class="number">192</span>);</span><br><span class="line">        *out_advance = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((byte &amp; <span class="number">240</span>) == <span class="number">224</span>) &#123;</span><br><span class="line">        cp=((<span class="type">uint32_t</span>) ps-&gt;sz[<span class="number">0</span>] &amp; ~<span class="number">240</span>) &lt;&lt; <span class="number">12</span> |</span><br><span class="line">        ((<span class="type">uint32_t</span>) ps-&gt;sz[<span class="number">1</span>] &amp; ~<span class="number">192</span>) &lt;&lt; <span class="number">6</span> |</span><br><span class="line">        ((<span class="type">uint32_t</span>) ps-&gt;sz[<span class="number">2</span>] &amp; ~<span class="number">192</span>);</span><br><span class="line">        *out_advance = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((byte &amp; <span class="number">248</span>) == <span class="number">240</span>) &#123;</span><br><span class="line">        cp=((<span class="type">uint32_t</span>) ps-&gt;sz[<span class="number">0</span>] &amp; ~<span class="number">248</span>) &lt;&lt; <span class="number">18</span> |</span><br><span class="line">                ((<span class="type">uint32_t</span>) ps-&gt;sz[<span class="number">1</span>] &amp; ~<span class="number">192</span>) &lt;&lt; <span class="number">12</span> |</span><br><span class="line">                ((<span class="type">uint32_t</span>) ps-&gt;sz[<span class="number">2</span>] &amp; ~<span class="number">192</span>) &lt;&lt; <span class="number">6</span> |</span><br><span class="line">                ((<span class="type">uint32_t</span>) ps-&gt;sz[<span class="number">3</span>] &amp; ~<span class="number">192</span>);</span><br><span class="line">        *out_advance = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// advance the pointer by</span></span><br><span class="line">    <span class="comment">// what we consumed</span></span><br><span class="line">    ps-&gt;sz+=*out_advance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大多数情况下，这个烂摊子是在处理 Unicode。除此之外，我们所做的只是推进state type的指针string_cb_state_t，并在完成时返回-1。</p>
<p>文件一是相似的，虽然在某些方面更简单，因为state它只是一个FILE句柄，它保持和前进自己的光标。请注意，在 Arduino 上，您将使用一个File对象并使用它，但示例是标准 C。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">file_callback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>* out_advance, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">void</span>* state)</span> </span>&#123;</span><br><span class="line">    FILE* h = (FILE*)state;</span><br><span class="line">    <span class="type">int32_t</span> cp;</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">fgetc</span>(h);</span><br><span class="line">    <span class="keyword">if</span> (i==<span class="number">-1</span>) &#123;</span><br><span class="line">        *out_advance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">uint8_t</span> byte = (<span class="type">uint8_t</span>)i;</span><br><span class="line">    <span class="keyword">if</span> ((byte &amp; <span class="number">128</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        cp = ((<span class="type">uint32_t</span>) i &amp; ~<span class="number">128</span>);</span><br><span class="line">        *out_advance = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((byte &amp; <span class="number">224</span>) == <span class="number">192</span>) &#123;</span><br><span class="line">        cp=((<span class="type">uint32_t</span>) i &amp; ~<span class="number">224</span>) &lt;&lt; <span class="number">6</span> |</span><br><span class="line">        ((<span class="type">uint32_t</span>) <span class="built_in">fgetc</span>(h) &amp; ~<span class="number">192</span>);</span><br><span class="line">        *out_advance = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((byte &amp; <span class="number">240</span>) == <span class="number">224</span>) &#123;</span><br><span class="line">        cp=((<span class="type">uint32_t</span>) i &amp; ~<span class="number">240</span>) &lt;&lt; <span class="number">12</span> |</span><br><span class="line">        ((<span class="type">uint32_t</span>) <span class="built_in">fgetc</span>(h) &amp; ~<span class="number">192</span>) &lt;&lt; <span class="number">6</span> |</span><br><span class="line">        ((<span class="type">uint32_t</span>) <span class="built_in">fgetc</span>(h) &amp; ~<span class="number">192</span>);</span><br><span class="line">        *out_advance = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((byte &amp; <span class="number">248</span>) == <span class="number">240</span>) &#123;</span><br><span class="line">        cp=((<span class="type">uint32_t</span>) i &amp; ~<span class="number">248</span>) &lt;&lt; <span class="number">18</span> |</span><br><span class="line">                ((<span class="type">uint32_t</span>) <span class="built_in">fgetc</span>(h) &amp; ~<span class="number">192</span>) &lt;&lt; <span class="number">12</span> |</span><br><span class="line">                ((<span class="type">uint32_t</span>) <span class="built_in">fgetc</span>(h) &amp; ~<span class="number">192</span>) &lt;&lt; <span class="number">6</span> |</span><br><span class="line">                ((<span class="type">uint32_t</span>) <span class="built_in">fgetc</span>(h) &amp; ~<span class="number">192</span>);</span><br><span class="line">        *out_advance = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第一个字符串之后，这个应该很明显。</p>
<p>请注意，所有这些例程都假定流是 7 位 ASCII 或有效的 UTF-8。没有进行检查，因此可能会发生非常糟糕的事情(TM)，尤其是在向字符串回调提供其他无效流的情况下。</p>
<p>现在让我们探索如何使用它。</p>
<p>对于输入文件中的每个命名正则表达式，match_Name()都会生成一个被调用的函数，其中Name 是输入文件中左侧的名称&#x3D;。</p>
<p>考虑文件 Example.rl 中的以下行：</p>
<p>Identifier &#x3D; ‘[<em>[:IsLetter:]][</em>[:IsLetterOrDigit:]]*’<br>这将生成一个名为的函数match_Identifier() ，然后可以使用该函数查找与该 Unicode 表达式匹配的字符串。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span>* test = </span><br><span class="line">        <span class="string">&quot;a1234 foobar /*5678 abc123 */ -&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="type">string_cb_state_t</span> st;</span><br><span class="line">    st.sz = test;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        Example_capture_t c = </span><br><span class="line">            <span class="built_in">match_Identifier</span>(&amp;pos, </span><br><span class="line">                            string_callback, </span><br><span class="line">                            &amp;st);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == c.length) &#123;</span><br><span class="line">            <span class="comment">// empty capture indicates end</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// print the capture buffer</span></span><br><span class="line">        <span class="comment">// (assumes ASCII)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;c.length;++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,(<span class="type">char</span>)c.capture[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的想法是一遍又一遍地调用match函数，每次都得到一个新的Example_capture_t（从输入文件的名称派生），直到一个返回一个length为0的a，表示到达了输入的末尾。</p>
<p>请注意，捕获缓冲区本身由int32_t值组成，这char与人们可能期望的不同。此匹配器捕获 UTF-32 代码点，而不是字符。这说明了接近末尾的代码循环并打印capture. 另请注意，捕获缓冲区不是以空值结尾的。</p>
<p>注意：ARDUINO如果您想将其与 Arduino 框架一起使用， 您应该在编译器的命令行上将其定义为常量。或者，将生成的标头修改为 unconditionally #include &lt;Arduino.h&gt;。</p>
<p>兴趣点<br>此代码生成保存 DFA 数组所需的最小元素类型。这意味着如果它是一个 ASCII 表达式并且状态机足够小，它将int8_t 用作数组元素类型。否则它将根据需要使用int16_t或int32_t。每个数组类型使用一个匹配器例程。这意味着将生成 1 到 3 个匹配器实现来处理所有匹配。它们几乎完全相同，它们的外观如下：</p>
<p>（原谅包装，这个套路又长又深）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Example_capture_t <span class="title">Example_runner32</span><span class="params">(<span class="type">int32_t</span>* dfa, <span class="type">int32_t</span>* blockEnd, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>* position, Example_callback callback, <span class="type">void</span>* callback_state)</span> </span>&#123;</span><br><span class="line">    Example_capture_t result;</span><br><span class="line">    result.position = <span class="number">0</span>;</span><br><span class="line">    result.length = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> adv = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tlen;</span><br><span class="line">    <span class="type">int32_t</span> tto;</span><br><span class="line">    <span class="type">int32_t</span> prlen;</span><br><span class="line">    <span class="type">int32_t</span> pmin;</span><br><span class="line">    <span class="type">int32_t</span> pmax;</span><br><span class="line">    <span class="type">int32_t</span> i, j;</span><br><span class="line">    <span class="type">int32_t</span> ch;</span><br><span class="line">    <span class="type">int32_t</span> state = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int32_t</span> acc = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> done;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> cursorPos = *position;</span><br><span class="line">    ch = <span class="built_in">callback</span>(&amp;adv, callback_state);</span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="number">-1</span>) &#123;</span><br><span class="line">        result.length = <span class="number">0</span>;</span><br><span class="line">        result.position = cursorPos;</span><br><span class="line">        acc = <span class="number">-1</span>;</span><br><span class="line">        done = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">start_dfa:</span><br><span class="line">            done = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ARDUINO) &amp;&amp; !defined(CORE_TEENSY) &amp;&amp; !defined(ESP32)</span></span><br><span class="line">            acc = (<span class="type">int32_t</span>)<span class="built_in">pgm_read_dword</span>((<span class="type">uint32_t</span>*)(dfa + (state++)));</span><br><span class="line">            tlen = (<span class="type">int32_t</span>)<span class="built_in">pgm_read_dword</span>((<span class="type">uint32_t</span>*)(dfa + (state++)));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            acc = dfa[state++];</span><br><span class="line">            tlen = dfa[state++];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tlen; ++i) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ARDUINO) &amp;&amp; !defined(CORE_TEENSY) &amp;&amp; !defined(ESP32)</span></span><br><span class="line">                tto = (<span class="type">int32_t</span>)<span class="built_in">pgm_read_dword</span>((<span class="type">uint32_t</span>*)(dfa + (state++)));</span><br><span class="line">                prlen = (<span class="type">int32_t</span>)<span class="built_in">pgm_read_dword</span>((<span class="type">uint32_t</span>*)(dfa + (state++)));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                tto = dfa[state++];</span><br><span class="line">                prlen = dfa[state++];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; prlen; ++j) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ARDUINO) &amp;&amp; !defined(CORE_TEENSY) &amp;&amp; !defined(ESP32)</span></span><br><span class="line">                    pmin = (<span class="type">int32_t</span>)<span class="built_in">pgm_read_dword</span>((<span class="type">uint32_t</span>*)(dfa + (state++)));</span><br><span class="line">                    pmax = (<span class="type">int32_t</span>)<span class="built_in">pgm_read_dword</span>((<span class="type">uint32_t</span>*)(dfa + (state++)));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                    pmin = dfa[state++];</span><br><span class="line">                    pmax = dfa[state++];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                    <span class="keyword">if</span> (ch &lt; pmin) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (ch &lt;= pmax) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (result.length &lt; <span class="number">256</span>) &#123;</span><br><span class="line">                            result.capture[result.length++] = ch;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ch = <span class="built_in">callback</span>(&amp;adv, callback_state);</span><br><span class="line">                        ++cursorPos;</span><br><span class="line">                        state = tto;</span><br><span class="line">                        done = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">goto</span> start_dfa;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acc != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (blockEnd != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    state = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> (ch != <span class="number">-1</span>) &#123;</span><br><span class="line">                        acc = <span class="number">-1</span>;</span><br><span class="line">                        done = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">start_block_end:</span><br><span class="line">                            done = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ARDUINO) &amp;&amp; !defined(CORE_TEENSY) &amp;&amp; !defined(ESP32)</span></span><br><span class="line">                            acc = (<span class="type">int32_t</span>)<span class="built_in">pgm_read_dword</span>((<span class="type">uint32_t</span>*)(blockEnd + (state++)));</span><br><span class="line">                            tlen = (<span class="type">int32_t</span>)<span class="built_in">pgm_read_dword</span>((<span class="type">uint32_t</span>*)(blockEnd + (state++)));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                            acc = blockEnd[state++];</span><br><span class="line">                            tlen = blockEnd[state++];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tlen; ++i) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ARDUINO) &amp;&amp; !defined(CORE_TEENSY) &amp;&amp; !defined(ESP32)</span></span><br><span class="line">                                tto = (<span class="type">int32_t</span>)<span class="built_in">pgm_read_dword</span>((<span class="type">uint32_t</span>*)(blockEnd + (state++)));</span><br><span class="line">                                prlen = (<span class="type">int32_t</span>)<span class="built_in">pgm_read_dword</span>((<span class="type">uint32_t</span>*)(blockEnd + (state++)));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                                tto = blockEnd[state++];</span><br><span class="line">                                prlen = blockEnd[state++];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; prlen; ++j) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ARDUINO) &amp;&amp; !defined(CORE_TEENSY) &amp;&amp; !defined(ESP32)</span></span><br><span class="line">                                    pmin = (<span class="type">int32_t</span>)<span class="built_in">pgm_read_dword</span>((<span class="type">uint32_t</span>*)(blockEnd + (state++)));</span><br><span class="line">                                    pmax = (<span class="type">int32_t</span>)<span class="built_in">pgm_read_dword</span>((<span class="type">uint32_t</span>*)(blockEnd + (state++)));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                                    pmin = blockEnd[state++];</span><br><span class="line">                                    pmax = blockEnd[state++];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                                    <span class="keyword">if</span> (ch &lt; pmin) &#123;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="keyword">if</span> (ch &lt;= pmax) &#123;</span><br><span class="line">                                        <span class="keyword">if</span> (result.length &lt; <span class="number">256</span>) &#123;</span><br><span class="line">                                            result.capture[result.length++] = ch;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        ch = <span class="built_in">callback</span>(&amp;adv, callback_state);</span><br><span class="line">                                        ++cursorPos;</span><br><span class="line">                                        state = tto;</span><br><span class="line">                                        done = <span class="number">0</span>;</span><br><span class="line">                                        <span class="keyword">goto</span> start_block_end;</span><br><span class="line"></span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (acc != <span class="number">-1</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> result;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (result.length &lt; <span class="number">256</span>) &#123;</span><br><span class="line">                                result.capture[result.length++] = ch;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ch = <span class="built_in">callback</span>(&amp;adv, callback_state);</span><br><span class="line">                            ++cursorPos;</span><br><span class="line">                        &#125;</span><br><span class="line">                        state = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    state = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (result.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ch = <span class="built_in">callback</span>(&amp;adv, callback_state);</span><br><span class="line">            ++cursorPos;</span><br><span class="line">            state = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它是为感兴趣的读者提供的。我们不打算详细探讨它，因为它会遍历从正则表达式生成的数组，并且当这些数组被煮熟时，所有有趣的逻辑都已被烘焙。遍历它是有效的，但并不直观。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>新闻</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown基本语法</title>
    <url>/18133.html</url>
    <content><![CDATA[<p>原始设计文档中概述的 Markdown 元素。<br>概述<br>几乎所有 Markdown 应用程序都支持原始 Markdown 设计文档中概述的基本语法。Markdown 处理器之间存在细微的差异和差异——尽可能内联。</p>
<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>要创建标题，请#在单词或短语前添加数字符号 ( )。您使用的数字符号的数量应与标题级别相对应。例如，要创建三级标题 ( &lt; h3 &gt;)，请使用三个数字符号（例如，### My Header）。</p>
<table>
<thead>
<tr>
<th>Markdown</th>
<th>HTML</th>
<th>渲染输出</th>
</tr>
</thead>
<tbody><tr>
<td># Heading level 1</td>
<td>&lt;h1&gt;Heading level 1&lt;&#x2F;h1&gt;</td>
<td># 标题级别 1</td>
</tr>
<tr>
<td>## Heading level 2</td>
<td>&lt;h2&gt;Heading level 2&lt;&#x2F;h2&gt;</td>
<td>## 标题级别 2</td>
</tr>
<tr>
<td>### Heading level 3</td>
<td>&lt;h3&gt;Heading level 3&lt;&#x2F;h3&gt;</td>
<td>标题级别 3</td>
</tr>
<tr>
<td>#### Heading level 4</td>
<td>&lt;h4&gt;Heading level 4&lt;&#x2F;h4&gt;</td>
<td>标题级别 4</td>
</tr>
<tr>
<td>##### Heading level 5</td>
<td>&lt;h5&gt;Heading level 5&lt;&#x2F;h5&gt;</td>
<td>标题级别 5</td>
</tr>
<tr>
<td>###### Heading level 6</td>
<td>&lt;h6&gt;Heading level 6&lt;&#x2F;h6&gt;</td>
<td>标题级别 6</td>
</tr>
</tbody></table>
<h1 id="替代语法"><a href="#替代语法" class="headerlink" title="替代语法"></a>替代语法</h1><p>或者，在文本下方的行中，&#x3D;&#x3D;为第 1 级标题添加任意数量的字符或–为第 2 级标题添加字符。</p>
<table>
<thead>
<tr>
<th>Markdown</th>
<th>HTML</th>
<th>渲染输出</th>
</tr>
</thead>
<tbody><tr>
<td>Heading level 1 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</td>
<td>&lt;h1&gt;Heading level 1&lt;&#x2F;h1&gt;</td>
<td>标题级别 1</td>
</tr>
<tr>
<td>Heading level 2 —————</td>
<td>&lt;h2&gt;Heading level 2&lt;&#x2F;h2&gt;</td>
<td>标题级别 2</td>
</tr>
</tbody></table>
<h1 id="标题最佳实践"><a href="#标题最佳实践" class="headerlink" title="标题最佳实践"></a>标题最佳实践</h1><p>Markdown 应用程序不同意如何处理数字符号 ( #) 和标题名称之间的缺失空格。为了兼容性，请始终在数字符号和标题名称之间放置一个空格。</p>
<table>
<thead>
<tr>
<th>✅ 这样做</th>
<th>❌ 不要这样做</th>
</tr>
</thead>
<tbody><tr>
<td># Here’s a Heading</td>
<td>#Here’s a Heading</td>
</tr>
</tbody></table>
<p>为了兼容性，您还应该在标题前后放置空行。</p>
<table>
<thead>
<tr>
<th>✅ 这样做</th>
<th>❌ 不要这样做</th>
</tr>
</thead>
<tbody><tr>
<td>Try to put a blank line before…<br/># Heading<br/>…and after a heading.</td>
<td>Without blank lines, this might not look right.<br/># Heading <br/>Don’t do this!</td>
</tr>
</tbody></table>
<h1 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h1><p>要创建段落，请使用空行分隔一行或多行文本。</p>
<table>
<thead>
<tr>
<th>Markdown</th>
<th>HTML</th>
<th>渲染输出</th>
</tr>
</thead>
<tbody><tr>
<td>I really like using Markdown.<br/><br/>I think I’ll use it to format all of my documents from now on.</td>
<td>&lt;p&gt;I really like using Markdown.&lt;&#x2F;p&gt;<br/>&lt;p&gt;I think I’ll use it to format all of my documents from now on.&lt;&#x2F;p&gt;</td>
<td>我真的很喜欢使用 Markdown。<br/>我想从现在开始我会用它来格式化我的所有文档。</td>
</tr>
</tbody></table>
<h1 id="段落最佳实践"><a href="#段落最佳实践" class="headerlink" title="段落最佳实践"></a>段落最佳实践</h1><p>除非段落在列表中，否则不要使用空格或制表符缩进段落。</p>
<p> 注意：如果您需要在输出中缩进段落，请参阅如何缩进（制表符）部分。</p>
<table>
<thead>
<tr>
<th>✅ 这样做</th>
<th>❌ 不要这样做</th>
</tr>
</thead>
<tbody><tr>
<td>Don’t put tabs or spaces in front of your paragraphs.<br/><br/>Keep lines left-aligned like this.</td>
<td>This can result in unexpected formatting problems.  Don’t add tabs or spaces in front of paragraphs.</td>
</tr>
</tbody></table>
<p>尝试用四个空格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span><br></pre></td></tr></table></figure>
<h1 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h1><p>要创建换行符或换行符 ( &lt;br&gt;)，请以两个或多个空格结束一行，然后键入 return。</p>
<table>
<thead>
<tr>
<th>Markdown</th>
<th>HTML</th>
<th>渲染输出</th>
</tr>
</thead>
<tbody><tr>
<td>This is the first line.  <br/>And this is the second line.</td>
<td>&lt;p&gt;This is the first line.<br/>&lt;br&gt;And this is the second line.&lt;&#x2F;p&gt;</td>
<td>这是第一行。这是第二行。</td>
</tr>
</tbody></table>
<h1 id="换行最佳实践"><a href="#换行最佳实践" class="headerlink" title="换行最佳实践"></a>换行最佳实践</h1><p>您几乎可以在每个 Markdown 应用程序中使用两个或多个空格（通常称为“尾随空格”）作为换行符，但这是有争议的。在编辑器中很难看到尾随空格，而且许多人在每个句子后不小心或有意地放置了两个空格。出于这个原因，您可能希望使用尾随空格以外的其他内容作为换行符。如果您的 Markdown 应用程序支持 HTML，您可以使用&lt;br&gt;HTML 标签。</p>
<p>&lt;br&gt;为了兼容性，在行尾使用尾随空格或HTML 标记。</p>
<p>我不建议使用其他两个选项。CommonMark 和其他一些轻量级标记语言允许您\在行尾键入反斜杠 ( )，但并非所有 Markdown 应用程序都支持这一点，因此从兼容性角度来看，这不是一个很好的选择。并且至少有一些轻量级标记语言不需要在行尾添加任何内容——只需键入 return，它们就会创建一个换行符。</p>
<table>
<thead>
<tr>
<th>✅ 这样做</th>
<th>❌ 不要这样做</th>
</tr>
</thead>
<tbody><tr>
<td>First line with two spaces after.  <br/><br/>And the next line.<br/>First line with the HTML tag after.<br/>&lt;br&gt;And the next line.</td>
<td>First line with a backslash after.&lt;br&#x2F;&gt;And the next line.<br/>First line with nothing after.<br/>And the next line.</td>
</tr>
</tbody></table>
<h1 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h1><p>您可以通过将文本设置为粗体或斜体来增加重点。</p>
<h1 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h1><p>要加粗文本，请在单词或短语前后添加两个星号或下划线。为了强调单词的中间部分，请在字母周围添加两个不带空格的星号。</p>
<table>
<thead>
<tr>
<th>Markdown</th>
<th>HTML</th>
<th>渲染输出</th>
</tr>
</thead>
<tbody><tr>
<td>I just love ** bold text **.</td>
<td>I just love &lt;strong&gt;bold text&lt;&#x2F;strong&gt;.</td>
<td>我只是喜欢<strong>粗体字</strong>。</td>
</tr>
<tr>
<td>I just love _<em>bold text_</em>.</td>
<td>I just love &lt;strong&gt;bold text&lt;&#x2F;strong&gt;.</td>
<td>我只是喜欢粗体字。</td>
</tr>
<tr>
<td>Love**is**bold</td>
<td>Love&lt;strong&gt;is&lt;&#x2F;strong&gt;bold</td>
<td>love<strong>是</strong>粗体的</td>
</tr>
</tbody></table>
<h1 id="粗体的最佳实践"><a href="#粗体的最佳实践" class="headerlink" title="粗体的最佳实践"></a>粗体的最佳实践</h1><p>Markdown 应用程序不同意如何处理单词中间的下划线。为了兼容性，使用星号在单词中间加粗以表示强调。</p>
<table>
<thead>
<tr>
<th>✅ 这样做</th>
<th>❌ 不要这样做</th>
</tr>
</thead>
<tbody><tr>
<td>Love**is**bold</td>
<td>Love__is__bold</td>
</tr>
</tbody></table>
<h1 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h1><p>要使文本变为斜体，请在单词或短语前后添加一个星号或下划线。为了强调单词中间的斜体，请在字母周围添加一个不带空格的星号。</p>
<table>
<thead>
<tr>
<th>Markdown</th>
<th>HTML</th>
<th>渲染输出</th>
</tr>
</thead>
<tbody><tr>
<td>Italicized text is the *cat’s meow*.</td>
<td>Italicized text is the &lt;em&gt;cat’s meow&lt;&#x2F;em&gt;.</td>
<td>斜体字是猫的叫声。</td>
</tr>
<tr>
<td>Italicized text is the <em>cat’s meow</em>.</td>
<td>Italicized text is the &lt;em&gt;cat’s meow&lt;&#x2F;em&gt;.</td>
<td>斜体字是猫的叫声。</td>
</tr>
<tr>
<td>A*cat*meow</td>
<td>A&lt;em&gt;cat&lt;&#x2F;em&gt;meow</td>
<td>一只猫喵</td>
</tr>
</tbody></table>
<h1 id="斜体最佳实践"><a href="#斜体最佳实践" class="headerlink" title="斜体最佳实践"></a>斜体最佳实践</h1><p>Markdown 应用程序不同意如何处理单词中间的下划线。为了兼容性，使用星号将单词中间斜体表示强调。</p>
<table>
<thead>
<tr>
<th>✅ 这样做</th>
<th>❌ 不要这样做</th>
</tr>
</thead>
<tbody><tr>
<td>A*cat*meow</td>
<td>A_cat_meow</td>
</tr>
</tbody></table>
<h1 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h1><p>要同时强调粗体和斜体文本，请在单词或短语前后添加三个星号或下划线。要在单词中间加粗和斜体以表示强调，请在字母周围添加三个不带空格的星号。</p>
<table>
<thead>
<tr>
<th>Markdown</th>
<th>HTML</th>
<th>渲染输出</th>
</tr>
</thead>
<tbody><tr>
<td>This text is *** really important ***.</td>
<td>This text is &lt;em&gt;&lt;strong&gt;really important&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;.</td>
<td>这段文字真的很重要。</td>
</tr>
<tr>
<td>This text is <em><strong>really important</strong></em>.</td>
<td>This text is &lt;em&gt;&lt;strong&gt;really important&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;.</td>
<td>这段文字真的很重要。</td>
</tr>
<tr>
<td>This text is __*really important*__.</td>
<td>This text is &lt;em&gt;&lt;strong&gt;really important&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;.</td>
<td>这段文字真的很重要。</td>
</tr>
<tr>
<td>This text is **_really important_**.</td>
<td>This text is &lt;em&gt;&lt;strong&gt;really important&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;.</td>
<td>这段文字真的很重要。</td>
</tr>
<tr>
<td>This is really*** very *** important text.</td>
<td>This is really&lt;em&gt;&lt;strong&gt;very&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;important text.</td>
<td>这是非常重要的文本。</td>
</tr>
</tbody></table>
<p> 注意：em和标签的顺序strong可能会根据您使用的 Markdown 处理器而颠倒。</p>
<h1 id="粗体和斜体最佳实践"><a href="#粗体和斜体最佳实践" class="headerlink" title="粗体和斜体最佳实践"></a>粗体和斜体最佳实践</h1><p>Markdown 应用程序不同意如何处理单词中间的下划线。为了兼容性，使用星号在单词中间加粗和斜体表示强调。</p>
<table>
<thead>
<tr>
<th>✅ 这样做</th>
<th>❌ 不要这样做</th>
</tr>
</thead>
<tbody><tr>
<td>This is really*** very *** important text.</td>
<td>This is really___very___important text.</td>
</tr>
</tbody></table>
<h1 id="块引用"><a href="#块引用" class="headerlink" title="块引用"></a>块引用</h1><p>要创建块引用，请&gt;在段落前添加一个。</p>
<p>&gt; Dorothy followed her through many of the beautiful rooms in her castle.<br>渲染的输出如下所示：</p>
<blockquote>
<p>Dorothy followed her through many of the beautiful rooms in her castle.</p>
</blockquote>
<h1 id="带有多个段落的大引号"><a href="#带有多个段落的大引号" class="headerlink" title="带有多个段落的大引号"></a>带有多个段落的大引号</h1><p>块引用可以包含多个段落。&gt;在段落之间的空白行上添加一个。</p>
<p>&gt; Dorothy followed her through many of the beautiful rooms in her castle.<br>&gt;<br>&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.<br>渲染的输出如下所示：</p>
<blockquote>
<p>Dorothy followed her through many of the beautiful rooms in her castle.</p>
<p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p>
</blockquote>
<h1 id="嵌套块引用"><a href="#嵌套块引用" class="headerlink" title="嵌套块引用"></a>嵌套块引用</h1><p>块引用可以嵌套。&gt;&gt;在要嵌套的段落前面添加一个。</p>
<p>&gt; Dorothy followed her through many of the beautiful rooms in her castle.<br>&gt;<br>&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.<br>渲染的输出如下所示：</p>
<blockquote>
<p>Dorothy followed her through many of the beautiful rooms in her castle.</p>
<blockquote>
<p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p>
</blockquote>
</blockquote>
<h1 id="带有其他元素的块引用"><a href="#带有其他元素的块引用" class="headerlink" title="带有其他元素的块引用"></a>带有其他元素的块引用</h1><p>Blockquotes 可以包含其他 Markdown 格式的元素。并非所有元素都可以使用——您需要尝试看看哪些元素有效。</p>
<p>&gt; #### The quarterly results look great!<br>&gt;<br>&gt; - Revenue was off the chart.<br>&gt; - Profits were higher than ever.<br>&gt;<br>&gt;  <em>Everything</em> is going according to *<em>plan*</em>.<br>渲染的输出如下所示：</p>
<blockquote>
<h4 id="The-quarterly-results-look-great"><a href="#The-quarterly-results-look-great" class="headerlink" title="The quarterly results look great!"></a>The quarterly results look great!</h4><ul>
<li>Revenue was off the chart.</li>
<li>Profits were higher than ever.</li>
</ul>
<p> <em>Everything</em> is going according to <strong>plan</strong>.</p>
</blockquote>
<h1 id="Blockquotes-最佳实践"><a href="#Blockquotes-最佳实践" class="headerlink" title="Blockquotes 最佳实践"></a>Blockquotes 最佳实践</h1><p>为了兼容性，在块引用之前和之后放置空行。</p>
<table>
<thead>
<tr>
<th>✅ 这样做</th>
<th>❌ 不要这样做</th>
</tr>
</thead>
<tbody><tr>
<td>Try to put a blank line before…<br/>&gt; This is a blockquote<br/>…and after a blockquote.</td>
<td>Without blank lines,this might <br/>not look right.<br/>&gt; This is a blockquote<br/>Don’t do this!</td>
</tr>
</tbody></table>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>您可以将项目组织成有序列表和无序列表。</p>
<h1 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h1><p>要创建有序列表，请添加带有数字后跟句点的行项目。数字不必按数字顺序排列，但列表应以数字一开头。</p>
<table>
<thead>
<tr>
<th>Markdown</th>
<th>HTML</th>
<th>渲染输出</th>
</tr>
</thead>
<tbody><tr>
<td>1. First item<br/>2. Second item<br/>3. Third item<br/>4. Fourth item</td>
<td>&lt;ol&gt;<br/> &lt;li&gt;First item&lt;&#x2F;li&gt;<br/> &lt;li&gt;Second item&lt;&#x2F;li&gt;<br/> &lt;li&gt;Third item&lt;&#x2F;li&gt; <br/>&lt;li&gt;Fourth item&lt;&#x2F;li&gt;<br/>&lt;&#x2F;ol&gt;</td>
<td>第一项<br/>第二项<br/>第三项<br/>第四项</td>
</tr>
<tr>
<td>1. First item<br/>1. Second item<br/>1. Third item<br/>1. Fourth item</td>
<td>&lt;ol&gt;<br/>  &lt;li&gt;First item&lt;li &gt;<br/>  &lt;li&gt;Second item&lt;&#x2F;li&gt;<br/>  &lt;li&gt;Third item&lt;&#x2F;li&gt;<br/>  &lt;li&gt;Fourth item&lt;&#x2F;li&gt;<br/>&lt;&#x2F;ol&gt;</td>
<td>第一项<br/>第二项<br/>第三项<br/>第四项</td>
</tr>
<tr>
<td>1. First item<br/>8. Second item<br/>3. Third item<br/>5. Fourth item</td>
<td>&lt;ol&gt;<br/>  &lt;li&gt;First item&lt;&#x2F;li&gt;<br/>  &lt;li&gt;Second item&lt;&#x2F;li&gt;<br/>  &lt;li&gt;Third item&lt;&#x2F;li&gt;<br/>  &lt;li&gt;Fourth item&lt;&#x2F;li&gt;&lt;&#x2F;ol&gt;</td>
<td>第一项<br/>第二项<br/>第三项<br/>第四项</td>
</tr>
<tr>
<td>1. First item<br/>2. Second item<br/>3. Third item    <br/>1. Indented item    <br/>2. Indented item<br/>4. Fourth item</td>
<td>&lt;ol&gt;  <br/>&lt;li&gt;First item&lt;&#x2F;li&gt;  <br/>&lt;li&gt;Second item&lt;&#x2F;li&gt;  <br/>&lt;li&gt;Third item    <br/>&lt;ol&gt;      <br/>&lt;li&gt;Indented item&lt;&#x2F;li&gt;      <br/>&lt;li&gt;Indented item&lt;&#x2F;li&gt;    <br/>&lt;&#x2F;ol&gt;  <br/>&lt;&#x2F;li&gt;  <br/>&lt;li&gt;Fourth item&lt;&#x2F;li&gt;<br/>&lt;&#x2F;ol&gt;</td>
<td>第一项<br/>第二项<br/>第三项<br/>缩进的项目<br/>缩进的项目<br/>第四项</td>
</tr>
</tbody></table>
<h1 id="有序列表最佳实践"><a href="#有序列表最佳实践" class="headerlink" title="有序列表最佳实践"></a>有序列表最佳实践</h1><p>CommonMark 和其他一些轻量级标记语言允许您使用括号 ( )) 作为分隔符（例如，1) First item），但并非所有 Markdown 应用程序都支持这一点，因此从兼容性的角度来看，这不是一个很好的选择。为了兼容性，仅使用句点。</p>
<table>
<thead>
<tr>
<th>✅ 这样做</th>
<th>❌ 不要这样做</th>
</tr>
</thead>
<tbody><tr>
<td>1. First item<br/>2. Second item</td>
<td>1) First item<br/>2) Second item</td>
</tr>
</tbody></table>
<h1 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h1><p>要创建无序列表，请在行项目前添加破折号 ( -)、星号 ( *) 或加号 ( +)。缩进一项或多项以创建嵌套列表。</p>
<table>
<thead>
<tr>
<th>Markdown</th>
<th>HTML</th>
<th>渲染输出</th>
</tr>
</thead>
<tbody><tr>
<td>- First item<br/>- Second item<br/>- Third item<br/>- Fourth item</td>
<td>&lt;ul&gt;<br/>  &lt;li&gt;First item&lt;&#x2F;li&gt;<br/>  &lt;li&gt;Second item&lt;&#x2F;li&gt;<br/>  &lt;li&gt;Third item&lt;&#x2F;li&gt;<br/>  &lt;li&gt;Fourth item&lt;&#x2F;li&gt;<br/>&lt;&#x2F;ul&gt;</td>
<td>第一项<br/>第二项<br/>第三项<br/>第四项</td>
</tr>
<tr>
<td>+ First item<br/>+ Second item<br/>+ Third item<br/>+ Fourth item</td>
<td>&lt;ul&gt;<br/>&lt;li&gt;First item&lt;&#x2F;li&gt; <br/>&lt;li&gt;Second item&lt;&#x2F;li&gt; <br/>&lt;li&gt;Third item&lt;&#x2F;li&gt; <br/>&lt;li&gt;Fourth item&lt;&#x2F;li&gt;<br/>&lt;&#x2F;ul&gt;</td>
<td><br/>第一项<br/>第二项<br/>第三项<br/>第四项</td>
</tr>
<tr>
<td>- First item<br/>- Second item<br/>- Third item <br/>   - Indented item <br/>   - Indented item <br/>- Fourth item</td>
<td>&lt;ul&gt;<br/>  &lt;li&gt;First item&lt;&#x2F;li&gt;<br/>  &lt;li&gt;Second item&lt;&#x2F;li&gt;<br/>  &lt;li&gt;Third item<br/>    &lt;ul&gt;<br/>     &lt;li&gt;Indented item&lt;&#x2F;li&gt;<br/>     &lt;li&gt;Indented item&lt;&#x2F;li&gt; <br/>   &lt;&#x2F;ul&gt;<br/> &lt;&#x2F;li&gt; <br/> &lt;li&gt;Fourth item&lt;&#x2F;li&gt;<br/>&lt;&#x2F;ul&gt;</td>
<td><br/>第一项<br/>第二项<br/>第三项<br/>缩进的项目<br/>缩进的项目<br/>第四项</td>
</tr>
</tbody></table>
<h1 id="以数字开头的无序列表项"><a href="#以数字开头的无序列表项" class="headerlink" title="以数字开头的无序列表项"></a>以数字开头的无序列表项</h1><p>如果您需要以数字后跟句点开头的无序列表项，可以使用反斜杠 ( \)转义句点。</p>
<table>
<thead>
<tr>
<th>Markdown</th>
<th>HTML</th>
<th>渲染输出</th>
</tr>
</thead>
<tbody><tr>
<td>- 1968. A great year!<br/>- I think 1969 was second best.</td>
<td>&lt;ul&gt;<br/>  &lt;li&gt;1968. A great year!&lt;&#x2F;li&gt;<br/>  &lt;li&gt;I think 1969 was second best.&lt;&#x2F;li&gt;<br/>&lt;&#x2F;ul&gt;</td>
<td>1968. 伟大的一年！<br/>我认为 1969 年是第二好的。</td>
</tr>
</tbody></table>
<h1 id="无序列表最佳实践"><a href="#无序列表最佳实践" class="headerlink" title="无序列表最佳实践"></a>无序列表最佳实践</h1><p>Markdown 应用程序不同意如何处理同一列表中的不同分隔符。为了兼容性，不要在同一个列表中混合和匹配分隔符 - 选择一个并坚持使用它。</p>
<table>
<thead>
<tr>
<th>✅ 这样做</th>
<th>❌ 不要这样做</th>
</tr>
</thead>
<tbody><tr>
<td>- First item<br/>- Second item<br/>- Third item<br/>- Fourth item</td>
<td>+ First item<br/>* Second item<br/>- Third item<br/>+ Fourth item</td>
</tr>
</tbody></table>
<h1 id="在列表中添加元素"><a href="#在列表中添加元素" class="headerlink" title="在列表中添加元素"></a>在列表中添加元素</h1><p>要在列表中添加另一个元素同时保持列表的连续性，请将元素缩进四个空格或一个制表符，如以下示例所示。</p>
<blockquote>
<p>提示：如果事情没有像您期望的那样出现，请仔细检查您是否将列表中的元素缩进了四个空格或一个制表符。</p>
</blockquote>
<h1 id="段落-1"><a href="#段落-1" class="headerlink" title="段落"></a>段落</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* This is the first list item.</span><br><span class="line">* Here&#x27;s the second list item.</span><br><span class="line"></span><br><span class="line">    I need to add another paragraph below the second list item.</span><br><span class="line"></span><br><span class="line">* And here&#x27;s the third list item.</span><br></pre></td></tr></table></figure>
<p>渲染的输出如下所示：</p>
<ul>
<li><p>This is the first list item.</p>
</li>
<li><p>Here’s the second list item.</p>
<p>  I need to add another paragraph below the second list item.</p>
</li>
<li><p>And here’s the third list item.</p>
</li>
</ul>
<h1 id="块引用-1"><a href="#块引用-1" class="headerlink" title="块引用"></a>块引用</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* This is the first list item.</span><br><span class="line">* Here&#x27;s the second list item.</span><br><span class="line"></span><br><span class="line">    &gt; A blockquote would look great below the second list item.</span><br><span class="line"></span><br><span class="line">* And here&#x27;s the third list item.</span><br></pre></td></tr></table></figure>
<p>渲染的输出如下所示：</p>
<ul>
<li><p>This is the first list item.</p>
</li>
<li><p>Here’s the second list item.</p>
<blockquote>
<p>A blockquote would look great below the second list item.</p>
</blockquote>
</li>
<li><p>And here’s the third list item.</p>
</li>
</ul>
<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>代码块通常缩进四个空格或一个制表符。当它们在列表中时，将它们缩进八个空格或两个制表符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Open the file.</span><br><span class="line">2. Find the following code block on line 21:</span><br><span class="line"></span><br><span class="line">        &lt;html&gt;</span><br><span class="line">          &lt;head&gt;</span><br><span class="line">            &lt;title&gt;Test&lt;/title&gt;</span><br><span class="line">          &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">3. Update the title to match the name of your website.</span><br></pre></td></tr></table></figure>
<p>使用`&#96;&#96; 代码 `&#96;&#96;</p>
<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Open the file containing the Linux mascot.</span><br><span class="line">2. Marvel at its beauty.</span><br><span class="line"></span><br><span class="line">    ![Tux, the Linux mascot](/assets/images/tux.png)</span><br><span class="line"></span><br><span class="line">3. Close the file.</span><br></pre></td></tr></table></figure>
<p>渲染的输出如下所示：</p>
<p>打开包含 Linux 吉祥物的文件。<br>惊叹于它的美丽。</p>
<p>Tux，Linux 吉祥物</p>
<p>关闭文件。</p>
<h1 id="列表-1"><a href="#列表-1" class="headerlink" title="列表"></a>列表</h1><p>您可以将无序列表嵌套在有序列表中，反之亦然。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. First item</span><br><span class="line">2. Second item</span><br><span class="line">3. Third item</span><br><span class="line">    - Indented item</span><br><span class="line">    - Indented item</span><br><span class="line">4. Fourth item</span><br></pre></td></tr></table></figure>
<p>渲染的输出如下所示：</p>
<p>第一项<br>第二项<br>第三项<br>缩进的项目<br>缩进的项目<br>第四项</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>要将单词或短语表示为代码，请将其括在反引号 ( &#96;) 中。</p>
<table>
<thead>
<tr>
<th>Markdown</th>
<th>HTML</th>
<th>渲染输出</th>
</tr>
</thead>
<tbody><tr>
<td>At the command prompt, type <code>nano</code>.</td>
<td>At the command prompt, type &lt;code&gt;nano&lt;&#x2F;code&gt;.</td>
<td>在命令提示符处，键入nano.</td>
</tr>
</tbody></table>
<h1 id="转义反引号"><a href="#转义反引号" class="headerlink" title="转义反引号"></a>转义反引号</h1><p>如果要表示为代码的单词或短语包含一个或多个反引号，则可以通过将单词或短语括在双反引号 ( &#96;&#96;) 中来对其进行转义。</p>
<table>
<thead>
<tr>
<th>Markdown</th>
<th>HTML</th>
<th>渲染输出</th>
</tr>
</thead>
<tbody><tr>
<td>`` Use `code` in your Markdown file. ``</td>
<td>&lt;code&gt;Use `code` in your Markdown file.&lt;&#x2F;code&gt;</td>
<td><code>Use `code` in your Markdown file.</code></td>
</tr>
</tbody></table>
<h1 id="代码块-1"><a href="#代码块-1" class="headerlink" title="代码块"></a>代码块</h1><p>要创建代码块，请将块的每一行缩进至少四个空格或一个制表符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>渲染的输出如下所示：</p>
<p>&lt;html&gt;<br>  &lt;head&gt;<br>  &lt;&#x2F;head&gt;<br>&lt;&#x2F;html&gt;<br> 注意：要创建不缩进行的代码块，请使用围栏代码块。</p>
<h1 id="水平规则"><a href="#水平规则" class="headerlink" title="水平规则"></a>水平规则</h1><p>要创建水平线，请在一行上单独使用三个或更多星号 ( ***)、破折号 ( —) 或下划线 ( ___)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">_________________</span><br></pre></td></tr></table></figure>
<p>所有三个的渲染输出看起来相同：</p>
<hr>
<h1 id="水平规则最佳实践"><a href="#水平规则最佳实践" class="headerlink" title="水平规则最佳实践"></a>水平规则最佳实践</h1><p>为了兼容性，在横线前后放置空行。</p>
<table>
<thead>
<tr>
<th>✅ 这样做</th>
<th>❌ 不要这样做</th>
</tr>
</thead>
<tbody><tr>
<td>Try to put a blank line before…<br/><br/>—<br/><br/>…and after a horizontal rule.</td>
<td>Without blank lines, this would be a heading.<br/>—<br/>Don’t do this!</td>
</tr>
</tbody></table>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>要创建链接，请将链接文本括在括号中（例如，[Duck Duck Go]），然后紧跟在括号中的 URL（例如，(<a href="https://duckduckgo.com))./">https://duckduckgo.com)）。</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">My favorite search engine is [Duck Duck Go](https://duckduckgo.com).</span><br></pre></td></tr></table></figure>

<p>渲染的输出如下所示：</p>
<p>My favorite search engine is <a href="https://duckduckgo.com/">Duck Duck Go</a>.</p>
<blockquote>
<p>注意：要链接到同一页面上的元素，请参阅链接到标题 ID。要创建在新选项卡或窗口中打开的链接，请参阅链接目标部分。</p>
</blockquote>
<h1 id="添加标题"><a href="#添加标题" class="headerlink" title="添加标题"></a>添加标题</h1><p>您可以选择为链接添加标题。当用户将鼠标悬停在链接上时，这将显示为工具提示。要添加标题，请在 URL 后用引号将其括起来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">My favorite search engine is [Duck Duck Go](https://duckduckgo.com &quot;The best search engine for privacy&quot;).</span><br></pre></td></tr></table></figure>
<p>渲染的输出如下所示：</p>
<p>My favorite search engine is <a href="https://duckduckgo.com/" title="The best search engine for privacy">Duck Duck Go</a>.</p>
<h1 id="URL-和电子邮件地址"><a href="#URL-和电子邮件地址" class="headerlink" title="URL 和电子邮件地址"></a>URL 和电子邮件地址</h1><p>要将 URL 或电子邮件地址快速转换为链接，请将其括在尖括号中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;https://www.code2u.top&gt;</span><br><span class="line">&lt;fake@code2u.top&gt;</span><br></pre></td></tr></table></figure>

<p>渲染的输出如下所示：<br><a href="https://www.code2u.top/">https://www.code2u.top</a><br><a href="mailto:&#102;&#x61;&#107;&#x65;&#64;&#99;&#x6f;&#x64;&#x65;&#x32;&#117;&#46;&#116;&#x6f;&#x70;">&#102;&#x61;&#107;&#x65;&#64;&#99;&#x6f;&#x64;&#x65;&#x32;&#117;&#46;&#116;&#x6f;&#x70;</a></p>
<h1 id="格式化链接"><a href="#格式化链接" class="headerlink" title="格式化链接"></a>格式化链接</h1><p>要强调链接，请在方括号和圆括号前后添加星号。要将链接表示为code，请在括号中添加反引号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I love supporting the **[EFF](https://eff.org)**.</span><br><span class="line">This is the *[Markdown Guide](https://www.code2u.top)*.</span><br><span class="line">See the section on [`code`](#code).</span><br></pre></td></tr></table></figure>

<p>渲染的输出如下所示：</p>
<p>I love supporting the <strong><a href="https://eff.org/">EFF</a></strong>.<br>This is the <em><a href="https://www.code2u.top/">Markdown Guide</a></em>.<br>See the section on <a href="#code"><code>code</code></a>.</p>
<h1 id="参考风格的链接"><a href="#参考风格的链接" class="headerlink" title="参考风格的链接"></a>参考风格的链接</h1><p>参考风格的链接是一种特殊的链接，它使 URL 更容易在 Markdown 中显示和阅读。参考风格的链接由两部分构成：与文本保持内联的部分和存储在文件中其他位置以使文本易于阅读的部分。</p>
<p>格式化链接的第一部分<br>引用样式链接的第一部分使用两组括号进行格式化。第一组括号包围应该显示为链接的文本。第二组括号显示一个标签，用于指向您存储在文档中其他位置的链接。</p>
<p>虽然不是必需的，但您可以在第一组和第二组括号之间包含一个空格。第二组括号中的标签不区分大小写，可以包含字母、数字、空格或标点符号。</p>
<p>这意味着以下示例格式与链接的第一部分大致相同：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[hobbit-hole][1]</span><br><span class="line">[hobbit-hole] [1]</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Hobbit#Lifestyle" title="Hobbit lifestyles">hobbit-hole</a></li>
<li>[hobbit-hole] <a href="https://en.wikipedia.org/wiki/Hobbit#Lifestyle" title="Hobbit lifestyles">1</a></li>
</ul>
<h1 id="格式化链接的第二部分"><a href="#格式化链接的第二部分" class="headerlink" title="格式化链接的第二部分"></a>格式化链接的第二部分</h1><p>引用样式链接的第二部分使用以下属性进行格式化：</p>
<ol>
<li>括号中的标签紧跟一个冒号和至少一个空格（例如，[label]: ）。</li>
<li>链接的 URL，您可以选择将其括在尖括号中。</li>
<li>链接的可选标题，可以用双引号、单引号或括号括起来。<br>这意味着以下示例格式对于链接的第二部分都大致相同：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle</span><br><span class="line">[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle &quot;Hobbit lifestyles&quot;</span><br><span class="line">[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle &#x27;Hobbit lifestyles&#x27;</span><br><span class="line">[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle (Hobbit lifestyles)</span><br><span class="line">[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; &quot;Hobbit lifestyles&quot;</span><br><span class="line">[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; &#x27;Hobbit lifestyles&#x27;</span><br><span class="line">[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; (Hobbit lifestyles)</span><br></pre></td></tr></table></figure>
<p>您可以将链接的第二部分放在 Markdown 文档中的任何位置。有些人将它们放在它们出现的段落之后，而另一些人将它们放在文档的末尾（如尾注或脚注）。</p>
<h1 id="将零件放在一起的示例"><a href="#将零件放在一起的示例" class="headerlink" title="将零件放在一起的示例"></a>将零件放在一起的示例</h1><p>假设您将 URL 作为标准 URL 链接添加到段落，它在 Markdown 中如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In a hole in the ground there lived a hobbit. Not a nasty, dirty, wet hole, filled with the ends</span><br><span class="line">of worms and an oozy smell, nor yet a dry, bare, sandy hole with nothing in it to sit down on or to</span><br><span class="line">eat: it was a [hobbit-hole](https://en.wikipedia.org/wiki/Hobbit#Lifestyle &quot;Hobbit lifestyles&quot;), and that means comfort.</span><br></pre></td></tr></table></figure>
<p>尽管它可能指向有趣的附加信息，但显示的 URL 实际上并没有给现有的原始文本添加太多内容，只是使其更难阅读。要解决这个问题，您可以像这样格式化 URL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In a hole in the ground there lived a hobbit. Not a nasty, dirty, wet hole, filled with the ends</span><br><span class="line">of worms and an oozy smell, nor yet a dry, bare, sandy hole with nothing in it to sit down on or to</span><br><span class="line">eat: it was a [hobbit-hole][1], and that means comfort.</span><br><span class="line"></span><br><span class="line">[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; &quot;Hobbit lifestyles&quot;</span><br></pre></td></tr></table></figure>
<p>在上述两种情况下，渲染的输出都是相同的：</p>
<p>In a hole in the ground there lived a hobbit. Not a nasty, dirty, wet hole, filled with the ends<br>of worms and an oozy smell, nor yet a dry, bare, sandy hole with nothing in it to sit down on or to<br>eat: it was a <a href="https://en.wikipedia.org/wiki/Hobbit#Lifestyle" title="Hobbit lifestyles">hobbit-hole</a>, and that means comfort.</p>
<h1 id="链接的-HTML-将是："><a href="#链接的-HTML-将是：" class="headerlink" title="链接的 HTML 将是："></a>链接的 HTML 将是：</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&quot; title=&quot;Hobbit lifestyles&quot;&gt;hobbit-hole&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h1 id="链接最佳实践"><a href="#链接最佳实践" class="headerlink" title="链接最佳实践"></a>链接最佳实践</h1><p>Markdown 应用程序不同意如何处理 URL 中间的空格。为了兼容性，请尝试使用 . 对任何空格进行 URL 编码%20。或者，如果您的 Markdown 应用程序支持 HTML，您可以使用aHTML 标签。</p>
<table>
<thead>
<tr>
<th>✅ 这样做</th>
<th>❌ 不要这样做</th>
</tr>
</thead>
<tbody><tr>
<td><code>[link](https://www.example.com/my%20great%20page)&amp;lt;a href=&quot;https://www.example.com/my great page&quot;&amp;gt;link&amp;lt;/a&amp;gt;	</code></td>
<td><code>[link](https://www.example.com/my great page)</code></td>
</tr>
</tbody></table>
<h1 id="图片-1"><a href="#图片-1" class="headerlink" title="图片"></a>图片</h1><p>要添加图像，请添加感叹号 ( !)，后跟括号中的替代文本，以及括号中的图像资源的路径或 URL。您可以选择在路径或 URL 后添加引号中的标题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![The San Juan Mountains are beautiful!](/assets/images/san-juan-mountains.jpg &quot;San Juan Mountains&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<blockquote>
<p>注意：要调整图像大小，请参阅图像大小部分。要添加说明，请参阅图像说明部分。<br>链接图像<br>要添加指向图像的链接，请将图像的 Markdown 括在括号中，然后将链接添加到括号中。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[![An old rock in the desert](/assets/images/shiprock.jpg &quot;Shiprock, New Mexico by Beau Rogers&quot;)](https://www.flickr.com/photos/beaurogers/31833779864/in/photolist-Qv3rFw-34mt9F-a9Cmfy-5Ha3Zi-9msKdv-o3hgjr-hWpUte-4WMsJ1-KUQ8N-deshUb-vssBD-6CQci6-8AFCiD-zsJWT-nNfsgB-dPDwZJ-bn9JGn-5HtSXY-6CUhAL-a4UTXB-ugPum-KUPSo-fBLNm-6CUmpy-4WMsc9-8a7D3T-83KJev-6CQ2bK-nNusHJ-a78rQH-nw3NvT-7aq2qf-8wwBso-3nNceh-ugSKP-4mh4kh-bbeeqH-a7biME-q3PtTf-brFpgb-cg38zw-bXMZc-nJPELD-f58Lmo-bXMYG-bz8AAi-bxNtNT-bXMYi-bXMY6-bXMYv)</span><br></pre></td></tr></table></figure>


<h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><p>要显示原本用于在 Markdown 文档中格式化文本的文字字符，\请在字符前面添加反斜杠 ( )。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\* Without the backslash, this would be a bullet in an unordered list.</span><br></pre></td></tr></table></figure>

<p>渲染的输出如下所示：</p>
<ul>
<li>如果没有反斜杠，这将是无序列表中的项目符号。</li>
</ul>
<h1 id="你可以逃脱的角色"><a href="#你可以逃脱的角色" class="headerlink" title="你可以逃脱的角色"></a>你可以逃脱的角色</h1><p>您可以使用反斜杠来转义以下字符。</p>
<table>
<thead>
<tr>
<th>特点</th>
<th>姓名</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>反斜杠</td>
</tr>
<tr>
<td>&#96;</td>
<td>反引号（另请参见代码中的转义反引号）</td>
</tr>
<tr>
<td>*</td>
<td>星号</td>
</tr>
<tr>
<td>_</td>
<td>下划线</td>
</tr>
<tr>
<td>{ }</td>
<td>大括号</td>
</tr>
<tr>
<td>[ ]</td>
<td>括号</td>
</tr>
<tr>
<td>&lt; &gt;</td>
<td>尖括号</td>
</tr>
<tr>
<td>( )</td>
<td>括号</td>
</tr>
<tr>
<td>#</td>
<td>英镑符号</td>
</tr>
<tr>
<td>+</td>
<td>加号</td>
</tr>
<tr>
<td>-</td>
<td>减号（连字符）</td>
</tr>
<tr>
<td>.</td>
<td>点</td>
</tr>
<tr>
<td>！</td>
<td>感叹号</td>
</tr>
<tr>
<td>|</td>
<td>管道（另见表中的逃逸管道）</td>
</tr>
</tbody></table>
<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p>许多 Markdown 应用程序允许您在 Markdown 格式的文本中使用 HTML 标签。如果您更喜欢某些 HTML 标记而不是 Markdown 语法，这将很有帮助。例如，有些人发现对图像使用 HTML 标记更容易。当您需要更改元素的属性（例如指定文本的颜色或更改图像的宽度）时，使用 HTML 也很有帮助。</p>
<p>要使用 HTML，请将标签放在 Markdown 格式文件的文本中。</p>
<p>This <strong>word</strong> is bold. This &lt;em&gt;word&lt;&#x2F;em&gt; is italic.<br>渲染的输出如下所示：</p>
<p>这个词是粗体的。这个词是斜体的。</p>
<h1 id="HTML-最佳实践"><a href="#HTML-最佳实践" class="headerlink" title="HTML 最佳实践"></a>HTML 最佳实践</h1><p>出于安全原因，并非所有 Markdown 应用程序都支持 Markdown 文档中的 HTML。如有疑问，请查看您的 Markdown 应用程序文档。某些应用程序仅支持 HTML 标记的子集。</p>
<p>使用空行将块级 HTML 元素（如&lt;div&gt;、&lt;table&gt;、&lt;pre&gt;和&lt;p&gt;）与周围的内容分开。尽量不要用制表符或空格缩进标签——这会干扰格式。</p>
<p>您不能在块级 HTML 标记中使用 Markdown 语法。例如，&lt;p&gt;italic and **bold**&lt;&#x2F;p&gt;不会工作。</p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown扩展语法</title>
    <url>/57876.html</url>
    <content><![CDATA[<p>基于基本 Markdown 语法的高级功能。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>原始 Markdown 设计文档中概述的基本语法添加了许多日常所需的元素，但对于某些人来说还不够。这就是扩展语法的用武之地。</p>
<p>一些个人和组织通过添加其他元素（如表格、代码块、语法突出显示、URL 自动链接和脚注）来扩展基本语法。这些元素可以通过使用基于基本 Markdown 语法的轻量级标记语言来启用，或者通过向兼容的 Markdown 处理器添加扩展来启用。</p>
<h2 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h2><p>并非所有 Markdown 应用程序都支持扩展语法元素。您需要检查您的应用程序使用的轻量级标记语言是否支持您要使用的扩展语法元素。如果没有，仍然可以在 Markdown 处理器中启用扩展。</p>
<h2 id="轻量级标记语言"><a href="#轻量级标记语言" class="headerlink" title="轻量级标记语言"></a>轻量级标记语言</h2><p>有几种轻量级标记语言是Markdown的超集。它们包括基本语法，并通过添加其他元素（如表格、代码块、语法突出显示、URL 自动链接和脚注）来构建它。许多最流行的 Markdown 应用程序使用以下轻量级标记语言之一：</p>
<p>通用标志 <a href="https://commonmark.org/">https://commonmark.org/</a><br>GitHub Flavored Markdown (GFM) <a href="https://github.github.com/gfm/">https://github.github.com/gfm/</a><br>Markdown Extra <a href="https://michelf.ca/projects/php-markdown/extra/">https://michelf.ca/projects/php-markdown/extra/</a><br>MultiMarkdown <a href="https://fletcherpenney.net/multimarkdown/">https://fletcherpenney.net/multimarkdown/</a><br>R Markdown <a href="https://rmarkdown.rstudio.com/">https://rmarkdown.rstudio.com/</a></p>
<h2 id="降价处理器"><a href="#降价处理器" class="headerlink" title="降价处理器"></a>降价处理器</h2><p>有几十个 Markdown 处理器可用。其中许多允许您添加启用扩展语法元素的扩展。查看处理器的文档以获取更多信息。</p>
<h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><p>要添加表格，请使用三个或更多连字符 ( —) 来创建每一列的标题，并使用竖线 ( |) 分隔每一列。为了兼容性，您还应该在行的任一端添加一个管道。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| Syntax      | Description |</span><br><span class="line">| ----------- | ----------- |</span><br><span class="line">| Header      | Title       |</span><br><span class="line">| Paragraph   | Text        |</span><br></pre></td></tr></table></figure>
<p>渲染的输出如下所示：</p>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Header</td>
<td>Title</td>
</tr>
<tr>
<td>Paragraph</td>
<td>Text</td>
</tr>
</tbody></table>
<p>单元格宽度可以变化，如下所示。渲染的输出看起来是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">| Syntax | Description |</span><br><span class="line">| --- | ----------- |</span><br><span class="line">| Header | Title |</span><br><span class="line">| Paragraph | Text |</span><br></pre></td></tr></table></figure>
<p> 提示：创建带有连字符和管道的表可能很乏味。要加快此过程，请尝试使用Markdown Tables Generator或AnyWayData Markdown Export。使用图形界面构建表格，然后将生成的 Markdown 格式文本复制到您的文件中。</p>
<h2 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h2><p>您可以通过在标题行内连字符的左侧、右侧或两侧添加冒号 ( ) 来将列中的文本向左、向右或居中对齐。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">| Syntax      | Description | Test Text     |</span><br><span class="line">| :---        |    :----:   |          ---: |</span><br><span class="line">| Header      | Title       | Here&#x27;s this   |</span><br><span class="line">| Paragraph   | Text        | And more      |</span><br></pre></td></tr></table></figure>
<p>渲染的输出如下所示：</p>
<table>
<thead>
<tr>
<th align="left">Syntax</th>
<th align="center">Description</th>
<th align="right">Test Text</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Header</td>
<td align="center">Title</td>
<td align="right">Here’s this</td>
</tr>
<tr>
<td align="left">Paragraph</td>
<td align="center">Text</td>
<td align="right">And more</td>
</tr>
</tbody></table>
<h2 id="格式化表格中的文本"><a href="#格式化表格中的文本" class="headerlink" title="格式化表格中的文本"></a>格式化表格中的文本</h2><p>您可以格式化表格中的文本。例如，您可以添加链接、代码（仅在反引号 ( &#96;) 中的单词或短语，而不是代码块）和强调。</p>
<p>您不能使用标题、块引用、列表、水平线、图像或大多数 HTML 标记。</p>
<p> 提示：您可以使用 HTML 创建换行符并在表格单元格中 添加列表。<br>转义表中的管道字符<br>|您可以使用其 HTML 字符代码 ( ) 在表格中显示竖线 ( ) 字符&amp;#124;</p>
<h2 id="围栏代码块"><a href="#围栏代码块" class="headerlink" title="围栏代码块"></a>围栏代码块</h2><p>基本的 Markdown 语法允许您通过将行缩进四个空格或一个制表符来创建代码块。如果您觉得不方便，请尝试使用围栏代码块。根据您的 Markdown 处理器或编辑器，您将在代码块前后的行上使用三个反引号 ( &#96;&#96;&#96;) 或三个波浪号 ( )。~~~最好的部分？您不必缩进任何行！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;firstName&quot;: &quot;John&quot;,</span><br><span class="line">  &quot;lastName&quot;: &quot;Smith&quot;,</span><br><span class="line">  &quot;age&quot;: 25</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>渲染的输出如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;firstName&quot;: &quot;John&quot;,</span><br><span class="line">  &quot;lastName&quot;: &quot;Smith&quot;,</span><br><span class="line">  &quot;age&quot;: 25</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 提示：需要在代码块内显示反引号？请参阅本节以了解如何逃避它们。</p>
<h2 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h2><p>许多 Markdown 处理器支持对受保护的代码块进行语法高亮显示。此功能允许您为编写代码的任何语言添加颜色突出显示。要添加语法突出显示，请在受保护的代码块之前的反引号旁边指定一种语言。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;lastName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Smith&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">25</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>渲染的输出如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;firstName&quot;: &quot;John&quot;,</span><br><span class="line">  &quot;lastName&quot;: &quot;Smith&quot;,</span><br><span class="line">  &quot;age&quot;: 25</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>脚注允许您添加注释和参考，而不会弄乱文档的正文。当您创建脚注时，带有链接的上标编号会出现在您添加脚注引用的位置。读者可以点击链接跳转到页面底部脚注的内容。</p>
<p>[^1]要创建脚注引用，请在方括号 ( )内添加插入符号和标识符。标识符可以是数字或单词，但不能包含空格或制表符。标识符仅将脚注引用与脚注本身相关联——在输出中，脚注按顺序编号。</p>
<p>在带有冒号和文本 ( [^1]: My footnote.) 的括号内使用另一个插入符号和数字添加脚注。您不必在文档末尾添加脚注。除了列表、块引号和表格等其他元素之外，您可以将它们放在任何位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Here&#x27;s a simple footnote,[^1] and here&#x27;s a longer one.[^bignote]</span><br><span class="line"></span><br><span class="line">[^1]: This is the first footnote.</span><br><span class="line"></span><br><span class="line">[^bignote]: Here&#x27;s one with multiple paragraphs and code.</span><br><span class="line"></span><br><span class="line">    Indent paragraphs to include them in the footnote.</span><br><span class="line"></span><br><span class="line">    `&#123; my code &#125;`</span><br><span class="line"></span><br><span class="line">    Add as many paragraphs as you like.</span><br></pre></td></tr></table></figure>
<p>渲染的输出如下所示：</p>
<p>Here’s a simple footnote,1 and here’s a longer one.2</p>
<p>This is the first footnote. ↩</p>
<p>Here’s one with multiple paragraphs and code.</p>
<p>Indent paragraphs to include them in the footnote.</p>
<p>{ my code }</p>
<p>Add as many paragraphs as you like. ↩</p>
<h2 id="标题-ID"><a href="#标题-ID" class="headerlink" title="标题 ID"></a>标题 ID</h2><p>许多 Markdown 处理器支持标题的自定义ID——一些 Markdown 处理器会自动添加它们。添加自定义 ID 允许您直接链接到标题并使用 CSS 修改它们。要添加自定义标题 ID，请将自定义 ID 括在与标题相同的行上的花括号中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### My Great Heading &#123;#custom-id&#125;</span><br></pre></td></tr></table></figure>
<p>HTML 如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h3 id=&quot;custom-id&quot;&gt;My Great Heading&lt;/h3&gt;</span><br></pre></td></tr></table></figure>
<h2 id="链接到标题-ID"><a href="#链接到标题-ID" class="headerlink" title="链接到标题 ID"></a>链接到标题 ID</h2><p>您可以通过创建带有数字符号 ( ) 后跟自定义标题 ID的标准链接来链接到文件中具有自定义 ID 的标题。#这些通常称为锚链接。</p>
<table>
<thead>
<tr>
<th>降价</th>
<th>HTML</th>
<th>渲染输出</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#heading-ids">Heading IDs</a></td>
<td><a href="#heading-ids">Heading IDs</a></td>
<td>标题 ID</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">其他网站可以通过将自定义标题 ID 添加到网页的完整 URL</span><br><span class="line">（例如，[Heading IDs](https://www.code2u.top/extended-syntax#heading-ids)）</span><br><span class="line">来链接到该标题。</span><br></pre></td></tr></table></figure>

<h2 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h2><p>一些 Markdown 处理器允许您创建术语的定义列表及其相应的定义。要创建定义列表，请在第一行键入术语。在下一行，键入一个冒号，后跟一个空格和定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">First Term</span><br><span class="line">: This is the definition of the first term.</span><br><span class="line"></span><br><span class="line">Second Term</span><br><span class="line">: This is one definition of the second term.</span><br><span class="line">: This is another definition of the second term.</span><br></pre></td></tr></table></figure>
<p>HTML 如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dl&gt;</span><br><span class="line">  &lt;dt&gt;First Term&lt;/dt&gt;</span><br><span class="line">  &lt;dd&gt;This is the definition of the first term.&lt;/dd&gt;</span><br><span class="line">  &lt;dt&gt;Second Term&lt;/dt&gt;</span><br><span class="line">  &lt;dd&gt;This is one definition of the second term. &lt;/dd&gt;</span><br><span class="line">  &lt;dd&gt;This is another definition of the second term.&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure>
<p>渲染的输出如下所示：</p>
<dl><dt>First Term</dt><dd>This is the definition of the first term.</dd></dl><dl><dt>Second Term<br>: This is one definition of the second term.</dt><dd>This is another definition of the second term.</dd></dl><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>您可以通过在单词中心放置一条水平线来删除单词。结果看起来像这样. 此功能允许您指出某些单词是错误的，不应包含在文档中。~~要删除单词，请在单词前后使用两个波浪号 ( )。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~~The world is flat.~~ We now know that the world is round.</span><br></pre></td></tr></table></figure>
<p>渲染的输出如下所示：</p>
<p><del>The world is flat.</del> We now know that the world is round.</p>
<h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><p>任务列表（也称为清单和待办事项列表）允许您创建带有复选框的项目列表。在支持任务列表的 Markdown 应用程序中，复选框会显示在内容旁边。要创建任务列表，请在任务列表项前添加破折号 ( -) 和带空格 ( ) 的括号。[ ]要选择复选框，x请在括号 ( [x]) 之间添加一个。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- [x] Write the press release</span><br><span class="line">- [ ] Update the website</span><br><span class="line">- [ ] Contact the media</span><br></pre></td></tr></table></figure>
<p>渲染的输出如下所示：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> Write the press release</li>
<li><input disabled="" type="checkbox"> Update the website</li>
<li><input disabled="" type="checkbox"> Contact the media</li>
</ul>
<h2 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h2><p>将表情符号添加到 Markdown 文件有两种方法：将表情符号复制并粘贴到 Markdown 格式的文本中，或键入emoji 短代码。</p>
<p>复制和粘贴表情符号<br>在大多数情况下，您可以简单地从Emojipedia等来源复制表情符号并将其粘贴到您的文档中。许多 Markdown 应用程序会自动以 Markdown 格式的文本显示表情符号。您从 Markdown 应用程序导出的 HTML 和 PDF 文件应显示表情符号。</p>
<p> 提示：如果您使用的是静态网站生成器，请确保将HTML 页面编码为 UTF-8。<br>使用表情符号简码<br>一些 Markdown 应用程序允许您通过输入表情符号短代码来插入表情符号。这些以冒号开头和结尾，并包含表情符号的名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Gone camping! :tent: Be back soon.</span><br><span class="line"></span><br><span class="line">That is so funny! :joy:</span><br></pre></td></tr></table></figure>
<p>渲染的输出如下所示：</p>
<p>Gone camping! ⛺ Be back soon.</p>
<p>That is so funny! 😂</p>
<blockquote>
<p>注意：您可以使用此表情符号简码列表，但请记住，表情符号简码因应用程序而异。有关更多信息，请参阅 Markdown 应用程序的文档。</p>
</blockquote>
<h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p>这并不常见，但一些 Markdown 处理器允许您突出显示文本。结果看起来像这样. &#x3D;&#x3D;要突出显示单词，请在单词前后使用两个等号 ( )。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I need to highlight these ==very important words==.</span><br></pre></td></tr></table></figure>
<p>渲染的输出如下所示：</p>
<p>I need to highlight these <mark>very important words</mark>.</p>
<p>或者，如果您的 Markdown 应用程序支持HTML，您可以使用markHTML 标签。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I need to highlight these &lt;mark&gt;very important words&lt;/mark&gt;.</span><br></pre></td></tr></table></figure>
<h2 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h2><p>这并不常见，但一些 Markdown 处理器允许您使用下标将一个或多个字符定位在略低于正常类型行的位置。要创建下标，~请在字符前后使用一个波浪号 ( )。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">H~2~O</span><br></pre></td></tr></table></figure>
<p>渲染的输出如下所示：</p>
<p>H<sub>2</sub>O</p>
<p> 提示：请务必在使用之前在您的 Markdown 应用程序中进行测试。一些 Markdown 应用程序在单词前后使用一个波浪号，不是用于下标，而是用于删除线。<br>或者，如果您的 Markdown 应用程序支持HTML，您可以使用subHTML 标签。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">H&lt;sub&gt;2&lt;/sub&gt;O</span><br></pre></td></tr></table></figure>
<h2 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h2><p>这并不常见，但一些 Markdown 处理器允许您使用上标将一个或多个字符定位在略高于正常类型行的位置。要创建上标，^请在字符前后使用一个插入符号 ( )。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X^2^</span><br></pre></td></tr></table></figure>
<p>渲染的输出如下所示：</p>
<p>X<sup>2</sup></p>
<p>或者，如果您的 Markdown 应用程序支持HTML，您可以使用supHTML 标签。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X&lt;sup&gt;2&lt;/sup&gt;</span><br></pre></td></tr></table></figure>
<h2 id="自动-URL-链接"><a href="#自动-URL-链接" class="headerlink" title="自动 URL 链接"></a>自动 URL 链接</h2><p>许多 Markdown 处理器会自动将 URL 转换为链接。这意味着如果您键入 <a href="http://www.code2u.top/">http://www.code2u.top</a> ，即使您没有使用括号，您的 Markdown 处理器也会自动将其转换为链接。</p>
<p><a href="http://www.code2u.top/">http://www.code2u.top</a><br>渲染的输出如下所示：</p>
<p><a href="http://www.code2u.top/">http://www.code2u.top</a></p>
<h2 id="禁用自动-URL-链接"><a href="#禁用自动-URL-链接" class="headerlink" title="禁用自动 URL 链接"></a>禁用自动 URL 链接</h2><p>如果您不希望自动链接 URL，可以通过将 URL 表示为带有反引号的代码来删除链接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`http://www.example.com`</span><br></pre></td></tr></table></figure>
<p>渲染的输出如下所示：</p>
<p><code>http://www.example.com</code></p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
