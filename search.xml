<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>微软在移动优先、云优先的世界中处于什么位置？</title>
    <url>/16583.html</url>
    <content><![CDATA[<p>微软继续推广移动优先、云优先的游戏计划。这包括影响他们全面工作的变化。今天在西雅图举行的 Microsoft Build 大会上，微软提到了一些关于他们在云和移动计划方面的立场的统计数据。</p>
<p>Microsoft Windows 10 月度活跃用户<br>微软世界的核心是他们的核心操作系统，Windows 10。Windows 10 月活跃用户达到 5 亿</p>
<p>商业办公 365 月活跃用户<br>Microsoft Office 365 现在拥有 1 亿月度商业用户。由于 Office 已成为许多企业用户的核心生产力平台，Microsoft 正在为 Office 开发人员提供更多机会。这包括他们在上周的一次教育会议上谈到的微软团队的公告，开发人员可以访问该公告以添加扩展来执行诸如添加通知、扩展和可操作消息之类的操作。开发人员还可以使用新的 Microsoft Graph API 来利用 Microsoft 内部的数据和智能。最后，Microsoft 正在为 Azure 上的生产应用程序提供一种方式，现在可以向数以亿计的 ISV 活跃办公用户公开。</p>
<span id="more"></span>
<p>Cortana 月度活跃用户<br>Cortana 1.41 亿活跃用户。虽然这是一个很大的数字，但它包括使用任何类型的 Cortana 交互（包括语音）的人。</p>
<p>Azure Active Directory 中的组织12<br>Azure Active Directory 在组织内继续增长。现在使用 Azure Active Directory 的组织已增加到 1200 万个。</p>
<p>使用 Microsoft 云的财富 500 强公司<br>虽然微软云可能不是领导者，但值得注意的是，财富 500 强公司正在使用微软云。使用微软云的财富 500 强公司的百分比现在超过 90%。</p>
<p>面向开发人员的认知服务<br>一个很大的嗡嗡声是认知服务。随着数据和智能的增长，认知服务现在可以大大增加开发人员的能力。微软声称是认知服务领域最广泛的产品之一，为开发人员提供了 29 种不同的服务。开发人员可以利用的这些服务包括视觉、语音、语言、搜索等。添加的一些新服务包括必应自定义搜索、自定义决策服务、视频索引器、演示翻译和自定义视觉服务。</p>
<p>将它们加在一起<br>这些数字只是触及了微软正在发生的事情的表面。寻找来自 Microsoft Build 的其他一些新闻的报道。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>微软</tag>
      </tags>
  </entry>
  <entry>
    <title>代码改变世界</title>
    <url>/1504.html</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![img](/pic/img20220727.png)</span><br><span class="line">sudo apt-get update</span><br><span class="line">./RNU-ME.sh</span><br></pre></td></tr></table></figure>


<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> attributes = [</span><br><span class="line">  <span class="string">&#x27;autocomplete=&quot;off&quot;&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;autocorrect=&quot;off&quot;&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;autocapitalize=&quot;off&quot;&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;spellcheck=&quot;false&quot;&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;contenteditable=&quot;true&quot;&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> attributesStr = attributes.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="regexp">/&lt;figure class=&quot;highlight ([a-zA-Z]+)&quot;&gt;.*?&lt;\/figure&gt;/</span>.<span class="title function_">test</span>(data.<span class="property">content</span>)) &#123;</span><br><span class="line">    data.<span class="property">content</span> = data.<span class="property">content</span>.<span class="title function_">replace</span>(<span class="regexp">/&lt;figure class=&quot;highlight ([a-zA-Z]+)&quot;&gt;.*?&lt;\/figure&gt;/</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> language = <span class="title class_">RegExp</span>.<span class="property">$1</span> || <span class="string">&#x27;plain&#x27;</span></span><br><span class="line">      <span class="keyword">var</span> lastMatch = <span class="title class_">RegExp</span>.<span class="property">lastMatch</span></span><br><span class="line">      lastMatch = lastMatch.<span class="title function_">replace</span>(<span class="regexp">/&lt;figure class=&quot;highlight /</span>, <span class="string">&#x27;&lt;figure class=&quot;iseeu highlight /&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;&lt;div class=&quot;highlight-wrap&quot;&#x27;</span> + attributesStr + <span class="string">&#x27;data-rel=&quot;&#x27;</span> + language.<span class="title function_">toUpperCase</span>() + <span class="string">&#x27;&quot;&gt;&#x27;</span> + lastMatch + <span class="string">&#x27;&lt;/div&gt;&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>







<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>Php</tag>
      </tags>
  </entry>
  <entry>
    <title>执行sudo apt-get update时，无法获得锁 /var/lib/apt/lists/lock</title>
    <url>/59101.html</url>
    <content><![CDATA[<p>百度到的方法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo kill 2224</span><br></pre></td></tr></table></figure>
<p>可是我发现不行，然后又找到其他方法，也不行。<br>后来发现是自己不小心虚拟机多开了几个，<br>干脆把电脑重启，才解决了这个问题。<br>只把虚拟机重启是不行的。</p>
<p>原因：刚装好的Ubantu系统，内部缺少很多软件源，这时，系统会自动启动软件源更新进程“apt-get”，并且它会一直存活。由于它在运行时，会占用软件源更新时的系统锁（以下称“系统更新锁”，此锁文件在“&#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;”目录下），而当有新的apt-get进程生成时，就会因为得不到系统更新锁而出现”E: 无法获得锁 &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;lock - open (11: Resource temporarily unavailable)”错误提示！因此，我们只要将原先的apt-get进程杀死，从新激活新的apt-get进程，就可以让新立德软件管理器正常工作了！</p>
<span id="more"></span>
<p>问题描述<br>在执行sudo apt-get update时，遇到如下问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E: 无法获得锁 /var/lib/apt/lists/lock。锁正由进程 2224（apt-get）持有</span><br><span class="line">N: 请注意，直接移除锁文件不一定是合适的解决方案，且可能损坏您的系统。</span><br><span class="line">E: 无法对目录 /var/lib/apt/lists/ 加锁</span><br></pre></td></tr></table></figure>
<p>根据提示，是因为进程2224占用了这个锁，linux系统一次只允许一个进程执行apt-get，因此只需要把这个进程杀掉就可以：<br>解决方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo kill 2224</span><br></pre></td></tr></table></figure>
<p>问题解决！</p>
<h3 id="解决E-Could-not-get-lock-x2F-var-x2F-lib-x2F-apt-x2F-lists-x2F-lock-open-11-Resource-temporarily-unavailable"><a href="#解决E-Could-not-get-lock-x2F-var-x2F-lib-x2F-apt-x2F-lists-x2F-lock-open-11-Resource-temporarily-unavailable" class="headerlink" title="解决E:Could not get lock &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;lock - open (11: Resource temporarily unavailable)"></a>解决E:Could not get lock &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;lock - open (11: Resource temporarily unavailable)</h3><p>出现这个问题的原因可能是有另外一个程序正在运行，导致资源被锁不可用。而导致资源被锁的原因，可能是上次安装时没正常完成，而导致出现此状况。</p>
<p>解决方法：输入以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo rm /var/cache/apt/archives/lock</span><br><span class="line">sudo rm /var/lib/dpkg/lock</span><br></pre></td></tr></table></figure>
<p>之后再安装想装的包，即可解决</p>
<p>今天玩ubuntu的时候，在弄更新源的时候，突然出现以下错误：<br>[1]+ Stopped                 sudo apt-get update<br>haiquan@haiquan-desktop:~$ sudo apt-get update<br>E: Could not get lock &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;lock - open (11: Resource temporarily unavailable)<br>E: Unable to lock the list directory<br>开始以为是权限不够，就是用 sudo apt-get update,发现还是报错，问题没有解决。于是上网搜索了一下，答案如下：<br>问题应该是之前那个更新被强制取消的问题，进程仍然还在。用这个命令查看一下：<br>ps -e | grep apt<br>显示结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6362 ? 00:00:00 apt</span><br><span class="line">6934 ? 00:00:00 apt-get</span><br><span class="line">7368 ? 00:00:00 synaptic</span><br></pre></td></tr></table></figure>
<p>然后就执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo killall apt</span><br><span class="line">sudo killall apt-get</span><br><span class="line">sudo killall synaptic</span><br></pre></td></tr></table></figure>
<p>再次在终端里查看ps -e | grep apt 没有任何结果了</p>
<p>继续执行sudo apt-get update</p>
<p>OK！</p>
<p>原因：刚装好的Ubantu系统，内部缺少很多软件源，这时，系统会自动启动软件源更新进程“apt-get”，并且它会一直存活。由于它在运行时，会占用软件源更新时的系统锁（以下称“系统更新锁”，此锁文件在“&#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;”目录下），而当有新的apt-get进程生成时，就会因为得不到系统更新锁而出现”E: 无法获得锁 &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;lock - open (11: Resource temporarily unavailable)”错误提示！因此，我们只要将原先的apt-get进程杀死，从新激活新的apt-get进程，就可以让新立德软件管理器正常工作了！</p>
<p>这时，你可以按一下步骤来解决：<br>1、输入以下命令：“ps -aux  &gt; temp.txt”.敲回车确定。这时会有“warning”出现，但不予理会。<br>2、输入以下命令：“grep -n apt-get temp.txt”键入回车确定。而后从命令输出中找到 apt-get 进程的PID。<br>3、输入以下命令：“sudo kill <PID>”。<br>4、完成。</p>
<p>or<br>如果提示错误:E: Could not get lock &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock - open (11 Resource temporarily unavailable)<br>输入</p>
<p>sudo rm &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;lock<br>即可</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu的系统设置不见了找回,然后更新软件源</title>
    <url>/57909.html</url>
    <content><![CDATA[<p>网上查到的方法都是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$sudo apt-get update</span><br><span class="line">$sudo apt-get install unity-control-center</span><br><span class="line">$sudo apt install gnome-control-center</span><br></pre></td></tr></table></figure>
<p>我现在遇到一个新情况，那就是我的更新源出错了。<br>我就是要找到【系统设置】换更新源，<br>现在让我直接执行update，会提示很多错误。</p>
<p>我在随便操作的时候，突然进入&#x2F;etc&#x2F;apt&#x2F;<br><img src="/pic/img20220727.png" alt="img"></p>
<p>当我双击sources.list的时候，就跳出了这个更新源的设置，<br>于是我顺便换了更新源，然后再执行那两条命令即可。</p>
<p>另外，系统设置是点屏幕右上角的开关按钮，和关机按钮在一起。</p>
<h3 id="Ubuntu-如何更新软件源-阿里源、华为源、清华源等"><a href="#Ubuntu-如何更新软件源-阿里源、华为源、清华源等" class="headerlink" title="Ubuntu 如何更新软件源(阿里源、华为源、清华源等)"></a>Ubuntu 如何更新软件源(阿里源、华为源、清华源等)</h3><p>前言<br>Ubuntu系统自带的更新源服务器在国外，下载速度一般很慢，所以更换为国内源就成为必要操作了。</p>
<span id="more"></span>
<p>一、Ubuntu 更新软件源的方法<br>Ubuntu 更新软件源的方法：<br>1、打开终端；<br>2、输入命令备份原有软件源文件；<br>3、打开sources.list文件并添加新的软件源地址；<br>4、输入命令更新系统软件源地址。</p>
<p>二、具体步骤<br>具体步骤如下：<br>1、使用快捷键【ctrl+alt+t】打开终端。<br>2、输入以下命令备份原有软件源文件。<br>cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.bak_yyyymmdd<br>3、再输入以下命令打开sources.list文件并添加新的软件源地址。<br>vim &#x2F;etc&#x2F;apt&#x2F;sources.list #打开sources.list文件</p>
<p>PS： 新安装的Ubuntu可能没有安装Vim, 用如下命令先安装Vim：<br>sudo apt-get install vim-gtk</p>
<p>在文件末尾添加新的软件源地址，常用国内源地址如下：<br>#阿里源地址<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-backports main restricted universe multiverse</p>
<p>#华为源地址<br>deb <a href="https://repo.huaweicloud.com/ubuntu/">https://repo.huaweicloud.com/ubuntu/</a> focal main restricted<br>deb <a href="https://repo.huaweicloud.com/ubuntu/">https://repo.huaweicloud.com/ubuntu/</a> focal-updates main restricted<br>deb <a href="https://repo.huaweicloud.com/ubuntu/">https://repo.huaweicloud.com/ubuntu/</a> focal universe<br>deb <a href="https://repo.huaweicloud.com/ubuntu/">https://repo.huaweicloud.com/ubuntu/</a> focal-updates universe<br>deb <a href="https://repo.huaweicloud.com/ubuntu/">https://repo.huaweicloud.com/ubuntu/</a> focal-backports main restricted universe<br>deb <a href="https://repo.huaweicloud.com/ubuntu/">https://repo.huaweicloud.com/ubuntu/</a> focal-security main restricted<br>deb <a href="https://repo.huaweicloud.com/ubuntu/">https://repo.huaweicloud.com/ubuntu/</a> focal-security universe</p>
<p>#中科大源地址<br>deb <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic main restricted universe multiverse<br>deb-src <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic main restricted universe multiverse<br>deb <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb-src <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb-src <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb-src <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb-src <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-proposed main restricted universe multiverse</p>
<p>#163源地址<br>deb <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic main restricted universe multiverse<br>deb <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb-src <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic main restricted universe multiverse<br>deb-src <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb-src <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb-src <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb-src <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic-backports main restricted universe multiverse</p>
<p>#清华源地址<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic main restricted universe multiverse<br>deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-backports main restricted universe ultiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-proposed main restricted universe ultiverse</p>
<p>4、输入命令更新系统软件源地址:<br>apt-get update<br>apt-get upgrade</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>换电脑把hexo从GitHub上克隆到本地-恢复使用操作</title>
    <url>/25333.html</url>
    <content><![CDATA[<p>先从github上克隆下来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:code8cn/code8cn.github.io.git</span><br></pre></td></tr></table></figure>
<p>然后进入目录执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>当然要已经安装好hexo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>一、配置环境<br>1.安装git（点击进入Git官网，如果嫌下载慢自行百度解决~）<br>2.Git与远程库进行SSH授权(点击查看教程Git的安装-与远程仓库GitHub配置)<br>2.安装node.js  （点击进入nodejs官网直接下载）</p>
<p>二.配置本地博客<br>1.安装hexo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>安装好后不需要初始化（hexo init）<br>2.克隆GitHub上保存的hexo网站原文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:code8cn/code8cn.github.io.git</span><br></pre></td></tr></table></figure>
<p>3.生成缺少的网站文件</p>
<p>进入克隆的目录，执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>因为上传GitHub时有.gitignore文件，所以上传到github上默认是忽略掉 node_modules等文件夹，即仓库的hexo分支并没有存储这些文件，所以需要install生成。</p>
<p>三.生成、部署（推荐）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>刚恢复本地hexo最好生成部署一下，接下来就像以前一样了。</p>
<p>参考资料1：<a href="https://www.zhihu.com/question/21193762/answer/489124966">https://www.zhihu.com/question/21193762/answer/489124966</a><br>参考资料2：<a href="https://www.jianshu.com/p/0b1fccce74e0">https://www.jianshu.com/p/0b1fccce74e0</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 安装nodejs最新版本简单方法</title>
    <url>/33390.html</url>
    <content><![CDATA[<p>···<br>sudo apt update -y<br>sudo apt install -y npm<br>sudo npm config set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a><br>sudo npm install n -g<br>sudo n stable<br>···</p>
<h3 id="ubuntu-上安装node-js-的简单方法"><a href="#ubuntu-上安装node-js-的简单方法" class="headerlink" title="ubuntu 上安装node.js 的简单方法"></a>ubuntu 上安装node.js 的简单方法</h3><p>一、安装<br>1.$ sudo apt-get install nodejs<br>2.$ sudo apt-get install npm</p>
<p>二、升级<br>    1.升级npm命令如下：</p>
<p>$ sudo npm install npm -g<br>&#x2F;usr&#x2F;local&#x2F;bin&#x2F;npm -&gt; &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;npm&#x2F;bin&#x2F;npm-cli.js<br><a href="mailto:&#110;&#x70;&#109;&#64;&#x32;&#x2e;&#x31;&#x34;&#46;&#x32;">&#110;&#x70;&#109;&#64;&#x32;&#x2e;&#x31;&#x34;&#46;&#x32;</a> &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;npm<br>2.升级node.js命令如下：<br>$ npm install –g n<br>$ n latest(升级node.js到最新版)  or $ n stable（升级node.js到最新稳定版）<br>    n后面也可以跟随版本号比如：$ n v0.10.26 或者 $ n 0.10.26</p>
<p>三、npm镜像替换为淘宝镜像</p>
<p>1.得到原本的镜像地址<br>$ npm get registry </p>
<blockquote>
<p><a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a><br>设成淘宝的<br>$ npm config set registry <a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org/</a></p>
</blockquote>
<p>2.换成原来的<br>$ npm config set registry <a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a></p>
<span id="more"></span>
<p>四、选装cnpm<br>1.说明：因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事。！来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”；<br>2.官方网址：<a href="http://npm.taobao.org;/">http://npm.taobao.org；</a><br>3.安装：命令提示符执行npm install cnpm -g –registry&#x3D;<a href="https://registry.npm.taobao.org;/">https://registry.npm.taobao.org；</a>  注意：安装完后最好查看其版本号cnpm -v或关闭命令提示符重新打开，安装完直接使用有可能会出现错误；</p>
<p>注：cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm（以下操作将以cnpm代替npm）</p>
<p>五、全局安装与本地安装<br>  npm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有-g而已，</p>
<p>   比如我们使用 npm 命令安装常用的 Node.js web框架模块 express:</p>
<p>$ npm install express          # 本地安装<br>$ npm install express -g       # 全局安装</p>
<p>六、卸载<br>1.先卸载 npm<br>  sudo npm uninstall npm -g<br>2.卸载nodejs<br>  sudo apt-get remove nodejs<br>方式二：nvm安装<br>安装<br>wget -qO- <a href="https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh">https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh</a> | bash<br>使用<br>安装成功后,需要关闭xshell，重新启动。nvm才会生效。</p>
<p>使用command -v nvm查看nvm是否安装成功</p>
<p>root@linuxidc:~# command -v nvm<br>nvm<br>查看已安装<br>通过nvm ls查看已安装的版本</p>
<p>$ nvm ls<br>            N&#x2F;A<br>node -&gt; stable (-&gt; N&#x2F;A) (default)<br>iojs -&gt; N&#x2F;A (default)<br>查看有哪些可安装<br>通过nvm ls-remote查看可使用版本</p>
<p>$ nvm ls-remote<br>        v0.1.14<br>        v0.1.15<br>        v0.1.16<br>        v0.1.17<br>        v0.1.18<br>…<br>安装nodejs<br>通过nvm install 7.8.0来安装，后面的版本号我们可以任意选择</p>
<p>root@linuxidc:~# nvm install 7.8.0<br>Downloading and installing node v6.2.0…<br>Downloading <a href="https://nodejs.org/dist/v7.8.0/node-v7.8.0-linux-x64.tar.xz">https://nodejs.org/dist/v7.8.0/node-v7.8.0-linux-x64.tar.xz</a>…<br>我们上面使用的是国外的服务器下载，很慢，耐心等待，nodejs和nvm成功安装！</p>
<h3 id="ubuntu-安装nodejs"><a href="#ubuntu-安装nodejs" class="headerlink" title="ubuntu 安装nodejs"></a>ubuntu 安装nodejs</h3><p>安装nodeJS之前，如果没有安装g++及 libssl-dev，则先要安装好，安装方法如下：</p>
<p>$ sudo apt-get install g++<br>$ sudo apt-get install libssl-dev</p>
<p>接下来，就可以下载安装nodejs了，，下面是安装步骤：</p>
<p>&#x2F;&#x2F; 下载<br>$ wget <a href="http://nodejs.org/dist/v0.10.24/node-v0.10.24.tar.gz">http://nodejs.org/dist/v0.10.24/node-v0.10.24.tar.gz</a><br>&#x2F;&#x2F; 解压：<br>$ tar -zxf node-v0.10.14.tar.gz $ cd node-v0.10.14<br>&#x2F;&#x2F; 默认安装： （默认在home目录下）<br>&#x2F;&#x2F;选择目录安装（将nodejs安装在&#x2F;usr&#x2F;local&#x2F;node目录下）<br>$ .&#x2F;configure -–prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;node<br>$ sudo make<br>$ sudo make install<br>这也是ubuntu 安装.tar.gz格式软件的方法。<br>　　1、tar -zxf　　***.tar.gz<br>　　2、cd 进入解压的目录<br>　　3、sudo .&#x2F;configure     –prefix　　&#x3D;　　&#x2F;usr&#x2F;local&#x2F;软件名 （–prefix 是软件装的目录）<br>　　4、sudo make<br>　　5、sudo make install<br>注：<br>　　1、–prefix 指定安装路径<br>　　不指定prefix，则可执行文件默认放在&#x2F;usr &#x2F;local&#x2F;bin，库文件默认放在&#x2F;usr&#x2F;local&#x2F;lib，配置文件默认放在&#x2F;usr&#x2F;local&#x2F;etc。其它的资源文件放在&#x2F;usr &#x2F;local&#x2F;share。你要卸载这个程序，要么在原来的make目录下用一次make uninstall（前提是make文件指定过uninstall）,要么去上述目录里面把相关的文件一个个手工删掉。<br>指定prefix，直接删掉一个文件夹就够了。　　</p>
<p>　　2、axconfig: port 1 not active</p>
<pre><code>       axconfig: port 2 not active
    出现这样的错误
</code></pre>
<p>　　（1）通过下面的方法卸载<br>　　　　sudo apt-get remove –purge node<br>　　　　sudo apt-get clean<br>　　（2）重新编译安装<br>　　　　sudo .&#x2F;configure<br>　　　　sudo make<br>　　　　sudo make install<br>　　　　重新编译来一边 OK 解决<br>　　（3）查看版本<br>　　　　输入node –v 或者node –version可以查看node.js当前的版本 </p>
<p>　　　　可能出现bash：usr&#x2F;sbin&#x2F;node 没有那个文件或目录 错误，使用sudo node -v </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>vercel绑定域名 解析@cname</title>
    <url>/30233.html</url>
    <content><![CDATA[<p>_vercel	TXT	默认	<br>vc-domain-verify&#x3D;code.quora8.cn,xxxx</p>
<p>code	CNAME	默认	<br>cname.vercel-dns.com</p>
<p>@  A  默认  76.76.21.21</p>
<p>www  CNAME  默认	cname.vercel-dns.com</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>一台电脑配置多个GitHub 或 其他git 仓库账号的方法</title>
    <url>/22981.html</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 取消全局设置</span><br><span class="line">git config --global --unset user.name</span><br><span class="line">git config --global --unset user.email</span><br><span class="line"></span><br><span class="line"># 进入项目目录</span><br><span class="line">git init</span><br><span class="line">git config user.email &quot;xxxxx@xxx.com&quot;</span><br><span class="line">git config user.name &quot;xxxx&quot;</span><br><span class="line"></span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>C#/.NET 中的动态语言运行时</title>
    <url>/2736.html</url>
    <content><![CDATA[<p>C# 中的动态语言运行时 DLR 概述<br>本文讨论动态语言运行时如何在 C#、DynamicObject 和 ExpandoObject 中工作，以及 IronPython 在 .NET 中的最简单用法。<br>介绍<br>尽管 C# 属于静态类型语言，但在该语言的最新版本中添加了一些动态功能。在本文中，我想展示动态语言运行时 (DLR)如何在 C# 中工作，DynamicObject以及IronPython在 .NET 中ExpandoObject的最简单用法。</p>
<p>C# 中的动态语言运行时 DLR<br>DLR（动态语言运行时）自.NET 4.0开始添加，代表IronPython和IronRuby等动态语言的运行时环境。</p>
<span id="more"></span>
<p>为了理解这个创新的本质，你需要知道静态类型和动态类型的语言之间的区别。在具有静态类型的语言中，所有类型及其成员 - 属性和方法的识别发生在编译阶段，而在动态语言中，系统在执行之前对类型的属性和方法一无所知。</p>
<p>由于这个DLR环境，C# 可以创建其成员在程序执行阶段被识别的动态对象，并将它们与具有静态类型的传统对象一起使用。</p>
<p>动态类型的使用是在 C# 中使用DLR的关键点，因此您可以在编译阶段跳过类型检查。此外，声明为动态的对象可以在程序运行期间更改其类型。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">            dynamic x = 3;     // here x is a integer</span><br><span class="line">            Console.WriteLine(x);</span><br><span class="line"> </span><br><span class="line">            x = &quot;Hello world&quot;; // now x is a string</span><br><span class="line">            Console.WriteLine(x);</span><br><span class="line"> </span><br><span class="line">            x = new Item_mast() </span><br><span class="line">                &#123; ItemId=1,ItemDesсription=&quot;Pen&quot;,Cost=10 &#125;; // now x is a Item_mast</span><br><span class="line">            Console.WriteLine(x);</span><br><span class="line">            Console.ReadLine();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  public class Item_mast</span><br><span class="line">        &#123;</span><br><span class="line">            public int ItemId &#123; get; set; &#125;</span><br><span class="line">            public string ItemDesсription &#123; get; set; &#125;</span><br><span class="line">            public int Cost &#123; get; set; &#125;</span><br><span class="line"> </span><br><span class="line">            public override string ToString()</span><br><span class="line">            &#123;</span><br><span class="line">                return ItemId.ToString() + &quot;, &quot;+ ItemDesсription + &quot; &quot; + Cost.ToString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/pic/img202208011001.png" alt="img"><br>图 1 - 基本 DLR 示例<br>让我们稍微描述一下代码。即使变量x多次更改其类型，此代码也可以正常工作。dynamic这是和之间的关键区别var。对于使用var关键字声明的变量，类型在编译时输出，然后在运行时不会更改。此外，您可以注意到dynamic类型和object类型之间的一些相似之处。我们可以很容易地替换表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dynamic x = 3;</span><br></pre></td></tr></table></figure>
<p>至：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">object x = 3</span><br></pre></td></tr></table></figure>
<p>我们有同样的结果。</p>
<p>但是，object类型也存在差异。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">object obj = 24;</span><br><span class="line">dynamic dyn = 24;</span><br><span class="line">obj += 4; // we can not do it!!!</span><br><span class="line">dyn += 4; // now is ok</span><br></pre></td></tr></table></figure>
<p>在行上obj +&#x3D; 4，我们将看到一个错误，因为该+&#x3D;操作不能应用于objectandint类型。使用声明为 的变量dynamic，这是可能的，因为它的类型只会在运行时知道。<br>需要注意的是，dynamic不仅可以应用于变量，还可以应用于方法和属性。让我们进行更改class并考虑下一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Item_mast</span><br><span class="line">        &#123;</span><br><span class="line">            public int ItemId &#123; get; set; &#125;</span><br><span class="line">            public string ItemDesсription &#123; get; set; &#125;</span><br><span class="line">            public dynamic Cost &#123; get; set; &#125; </span><br><span class="line"> </span><br><span class="line">            public dynamic GetPrice(dynamic value, string format)</span><br><span class="line">            &#123;</span><br><span class="line">                if (format == &quot;string&quot;)</span><br><span class="line">                &#123;</span><br><span class="line">                    return value + &quot; dollar&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (format == &quot;int&quot;)</span><br><span class="line">                &#123;</span><br><span class="line">                    return value;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    return 0.0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>Item_mass class定义了一个动态属性，因此在Cost为该属性设置值时，我们可以同时写Item.Cost&#x3D;10.00和Item.Cost&#x3D;”ten”。这两个选项都是正确的。还有一种GetPrice方法可以返回动态值。例如，根据参数，我们可以返回string价格表示或数字表示。该方法还将动态作为参数。因此，我们可以同时传递整数和小数作为收入值。我们来看看具体的应用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dynamic item1 = new Item_mast() &#123; ItemId = 1, ItemDesсription = &quot;Pen&quot;, Cost = 10 &#125;;</span><br><span class="line">            Console.WriteLine(item1);</span><br><span class="line">            Console.WriteLine(item1.GetPrice(10.00, &quot;int&quot;));</span><br><span class="line"> </span><br><span class="line">            dynamic item2 = new Item_mast() </span><br><span class="line">                            &#123; ItemId = 2, ItemDesсription = &quot;Pencil&quot;, Cost = &quot;five&quot; &#125;;</span><br><span class="line">            Console.WriteLine(item2);</span><br><span class="line">            Console.WriteLine(item2.GetPrice(5, &quot;string&quot;));</span><br><span class="line">            Console.ReadLine();</span><br></pre></td></tr></table></figure>

<p>结果，我们将拥有（图 2）：<br><img src="/pic/img202208011002.png" alt="img"><br>图 2 - 使用动态变量示例的结果<br>在这一部分中，我们通过示例检查了动态类型的使用。</p>
<p>DynamicObject 和 ExpandoObject<br>扩展对象<br>C#&#x2F;.NET开发能够创建非常类似于JavaScript中使用的动态对象。这种可能性是通过使用命名空间 Dynamic，特别是ExpandoObject类来提供的。</p>
<p>让我们考虑一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dynamic viewbag = new System.Dynamic.ExpandoObject();</span><br><span class="line">            viewbag.ItemId = 1;</span><br><span class="line">            viewbag.ItemDesсription = &quot;Pen&quot;;</span><br><span class="line">            viewbag.Cost = 10;</span><br><span class="line"></span><br><span class="line">            viewbag.Categories = new List&lt;string&gt; &#123; &quot;Flex&quot;, &quot;Soft&quot;, &quot;Luxury&quot; &#125;;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine($&quot;&#123;viewbag.ItemId&#125; ; </span><br><span class="line">                             &#123;viewbag.ItemDesсription&#125; ; &#123;viewbag.Cost&#125;&quot;);</span><br><span class="line">            foreach (var cat in viewbag.Categories)</span><br><span class="line">                Console.WriteLine(cat);</span><br><span class="line"></span><br><span class="line">            //declare method</span><br><span class="line">            viewbag.IncrementCost = (Action&lt;int&gt;)(x =&gt; viewbag.Cost += x);</span><br><span class="line">            viewbag.IncrementCost(6); // Increase Cost </span><br><span class="line">            Console.WriteLine($&quot;&#123;viewbag.ItemId&#125; ; </span><br><span class="line">                                &#123;viewbag.ItemDesсription&#125; ; &#123;viewbag.Cost&#125;&quot;);</span><br><span class="line"></span><br><span class="line">            Console.ReadLine();</span><br></pre></td></tr></table></figure>
<p>图 3 中的结果：<br><img src="/pic/img202208011003.png" alt="img"><br>图 3 - 使用 ExpandoObject() 的示例<br>动态ExpandoObject对象可以声明任何可以表示各种对象的属性。您还可以使用委托设置方法。</p>
<p>动态对象<br>该类DynamicObject与ExpandoObject. 但是，在 的情况下，我们需要通过继承并实现其方法DynamicObject来创建自己的类：DynamicObject</p>
<p>TryBinaryOperation()：在两个对象之间执行二元运算。等价于标准的二元运算，例如x + y)<br>TryConvert()：执行到特定类型的转换。相当于C#中的基本转换，例如(SomeType)obj<br>TryCreateInstance(): 创建一个对象的实例<br>TryDeleteIndex()：删除索引器<br>TryDeleteMember(): 删除一个属性或方法<br>TryGetIndex()：通过索引器按索引获取元素。在 C# 中，它可以等价于以下表达式int x &#x3D; collection[i]<br>TryGetMember(): 获取财产的价值。相当于访问一个属性，例如，string n &#x3D; item1.ItemDescription<br>TryInvoke(): 调用一个对象作为委托<br>TryInvokeMember(): 方法调用<br>TrySetIndex()：通过索引器按索引设置元素。在 C# 中，它可以等价于以下表达式collection[i] &#x3D; x;<br>TrySetMember(): 设置属性。相当于将一个项目值分配给一个property.Itemdescription &#x3D; “Pen”<br>TryUnaryOperation()：执行类似于 C# 中的一元运算的一元运算：x++<br>这些方法中的每一个都具有相同的检测模型：它们都返回一个布尔值，指示操作是否成功。作为第一个参数，它们都采用活页夹或活页夹对象。如果方法表示对可以接受参数的索引器或对象方法的调用，则object[] 数组用作第二个参数 - 它存储传递给方法或索引器的参数。</p>
<p>几乎所有的操作，除了设置和删除属性和索引器外，都会返回一个特定的值（例如，如果我们获取一个属性的值。在这种情况下，使用第三个参数out对象值，其目的是存储返回的object.</p>
<p>让我们通过创建一个dynamic对象类来举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Item_mast : DynamicObject</span><br><span class="line">        &#123;</span><br><span class="line">            Dictionary&lt;string, object&gt; members = new Dictionary&lt;string, object&gt;();</span><br><span class="line"> </span><br><span class="line">            // set prop</span><br><span class="line">            public override bool TrySetMember(SetMemberBinder binder, object value)</span><br><span class="line">            &#123;</span><br><span class="line">                members[binder.Name] = value;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            // get prop</span><br><span class="line">            public override bool TryGetMember(GetMemberBinder binder, out object result)</span><br><span class="line">            &#123;</span><br><span class="line">                result = null;</span><br><span class="line">                if (members.ContainsKey(binder.Name))</span><br><span class="line">                &#123;</span><br><span class="line">                    result = members[binder.Name];</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            // call method</span><br><span class="line">            public override bool TryInvokeMember</span><br><span class="line">            (InvokeMemberBinder binder, object[] args, out object result)</span><br><span class="line">            &#123;</span><br><span class="line">                dynamic method = members[binder.Name];</span><br><span class="line">                result = method((int)args[0]);</span><br><span class="line">                return result != null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>我们不能直接从 中创建对象DynamicObject，所以我们的Item_mast 类是一个孩子。在我们的类中，我们重新定义了三个方法。我们还使用Dictionary&lt;string, object&gt;成员来存储所有类成员，但我们也将它用于属性和方法。在这本字典中，keyshere 是names属性和方法，而values是values这些属性。<br>使用该TrySetMember() 方法，我们设置属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool TrySetMember(SetMemberBinder binder, object value)</span><br></pre></td></tr></table></figure>
<p>在这里，binder 参数存储要设置的属性的名称（binder.Name），value 是它需要设置的值。<br>TryGetMember是我们用来获取属性值的重写方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool TryGetMember(GetMemberBinder binder, out object result)</span><br></pre></td></tr></table></figure>
<p>同样，活页夹包含属性的名称，结果参数将包含结果的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The TryInvokeMember method is defined for calling methods:</span><br><span class="line"></span><br><span class="line">public override bool TryInvokeMember(InvokeMemberBinder binder, object[] args, out object result)</span><br><span class="line">&#123;</span><br><span class="line">    dynamic method = members[binder.Name];</span><br><span class="line">    result = method((int)args[0]);</span><br><span class="line">    return result != null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，使用 binder，我们获取方法，然后将args[0] 参数传递给它，首先将其转换为int类型，然后在result参数中设置方法的结果。也就是说，在这种情况下，假设该方法将采用该int类型的一个参数并返回一些结果。让我们举一个在我们的应用程序中使用类的例子：<br>现在让我们在程序中应用这个类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">   dynamic item = new Item_mast();</span><br><span class="line">            item.ItemId = 1;</span><br><span class="line">            item.ItemDesсription = &quot;Pen&quot;;</span><br><span class="line">            item.Cost = 10;</span><br><span class="line">            Func&lt;int, int&gt; Incr = delegate (int x) &#123; item.Cost += x; return item.Cost; &#125;;</span><br><span class="line">            item.IncrementCost = Incr;</span><br><span class="line">            Console.WriteLine($&quot;&#123;item.ItemId&#125; ; &#123;item.ItemDesсription&#125; ; &#123;item.Cost&#125;&quot;);         </span><br><span class="line">            item.IncrementCost(6);</span><br><span class="line">            Console.WriteLine($&quot;&#123;item.ItemId&#125; ; &#123;item.ItemDesсription&#125; ; &#123;item.Cost&#125;&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表达式item.ItemId &#x3D; 1 anditem.ItemDescription &#x3D; “Pen”将调用TrySetMember方法，数字将作为第一个变体中的第二个参数传递给该方法，而字符串 “Pen” 将在第二个变体中传递。<br>返回item.Cost 调用TryGetMember方法。<br>此外，该item对象还IncrementCost定义了一个方法，该方法表示匿名委托的操作delegate (int x) { item.Cost+&#x3D;x; return item.Cost; }。委托获取数字x，将Cost属性增加此数字并返回新值item.Cost.。当调用此方法时，TryInvokeMember将访问该方法。因此，item.Cost财产的价值将增加。</p>
<p>优点是您可以在使用动态对象时重新定义动态对象的行为，即，您实际上可以自己实现可动态扩展的对象。</p>
<p>在这一部分中，我们检查了示例的用法DynamicObject和ExpandoObject示例。</p>
<p>在 .NET 中使用 IronPython。<br>看起来为什么我们需要更多的语言，尤其是那些在另一种 C# 语言中使用的语言？但是，DLR环境的关键点之一是对IronPython和IronRuby等语言的支持。这在编写功能性客户端脚本时很有用。甚至可以说，现在客户端脚本的创建已经很普遍了，很多程序甚至游戏都支持添加用各种语言编写的客户端脚本。此外，可能有一些Python库的功能在 .NET 中可能不可用。在这种情况下，IronPython 可以再次帮助我们。</p>
<p>让我们看一个例子。首先，我们需要添加所有必要的NuGet包。为此，我将使用批处理管理器。首先，让我们添加DLR包（图 4）。</p>
<p>图 4<br><img src="/pic/img202208011004.png" alt="img"><br>图 4 - 添加 DLR 包<br>接下来，添加IronPython（图 5）：</p>
<p>图 5<br><img src="/pic/img202208011005.png" alt="img"><br>图 5 - 添加 IronPython 包<br>让我们添加最简单的代码，并且我们已经使用了 python：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            ScriptEngine engine = Python.CreateEngine();</span><br><span class="line">            engine.Execute(&quot;print &#x27;hello, world&#x27;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>结果，我们有（图6）：</p>
<p>图 6<br><img src="/pic/img202208011006.png" alt="img"><br>图 6 - 使用 IronPyton<br>这里使用了 Python 表达式，print ‘hello, world’ 它将 a 输出string到控制台。要创建执行脚本的引擎，需要ScriptEngine使用该类。它的Execute()方法执行脚本。<br>此外，我们可以创建一个文件，例如helloword.py并将文件的内容直接粘贴到我们的代码中：</p>
<p>engine.ExecuteFile(“D:&#x2F;&#x2F;helloword.py”);<br>此外，该ScriptScope对象允许您通过接收或安装脚本与脚本进行交互。但是，这已经超出了本文的范围。</p>
<p>结论<br>总之，我们研究了动态语言运行时 (DLR) 在 C# 中的工作方式、如何使用DynamicObject以及ExpandoObjectIronPython 如何在 .NET 中最简单的示例中工作。</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>微软</tag>
      </tags>
  </entry>
  <entry>
    <title>C#中的寻路算法</title>
    <url>/560.html</url>
    <content><![CDATA[<p>下载源 - 571.3 KB<br><a href="https://www.codeproject.com/KB/Articles/1221034/Source.zip">https://www.codeproject.com/KB/Articles/1221034/Source.zip</a><br>Path finding challenge<br><a href="http://airobots.azurewebsites.net/">http://airobots.azurewebsites.net/</a></p>
<p>在 Visual Studio 2017 中解压缩并打开解决方案</p>
<p>介绍<br>您有没有想过 GPS 应用程序如何计算到达所选目的地的最快方式？正如您将看到的，它实际上非常简单。</p>
<p>本文对此进行了解释，并提供了您可以随意使用的示例代码。文章还比较了两种常见的基本算法，Dijkstra 和 A*。</p>
<p>问题<br>假设你有一张地图。你知道你在哪里，你想去哪里。地图有连接节点（有坐标的地方）的道路（它们被称为边）。</p>
<p>从每个节点，你可以去一个或多个边。一条边有一个成本（例如，通过它所需的长度或时间）。<br>对于小地图，也许可以计算到目的地的所有可能路线并选择最短的路线。但这对于具有许多节点的地图来说不是很实用，因为组合呈指数增长。</p>
<span id="more"></span>
<p>迪杰斯特拉<br>Dijkstra 算法由 Edsger Dijkstra 于 1959 年发现。这是它的工作原理：</p>
<p>从起始节点开始，将所有连接的节点添加到优先级队列中。<br>按最低成本对优先级队列进行排序，并使第一个节点成为当前节点。<br>对于每个子节点，选择通向最短路径的最佳开始。<br>当从一个节点调查所有边时，该节点是“ Visited”，你不需要再去那里。<br>将连接到当前节点的每个子节点添加到优先级队列中。<br>转到第 2 步，直到队列为空。<br>递归地创建从头到尾引导最短路径的每个节点节点的列表。<br>反转列表，您找到了最短路径<br>换句话说，对于节点的每个子节点，递归地测量它到起点的距离。存储距离和哪个节点导致开始的最短路径。当您到达结束节点时，以最短的方式递归地回到起点，反转该列表，您就有了最短路径。</p>
<p>下面是我在 C# 代码中的 Dijkstra 算法实现。可能比上面的更容易理解。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Node&gt; <span class="title">GetShortestPathDijkstra</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    DijkstraSearch();</span><br><span class="line">    <span class="keyword">var</span> shortestPath = <span class="keyword">new</span> List&lt;Node&gt;();</span><br><span class="line">    shortestPath.Add(End);</span><br><span class="line">    BuildShortestPath(shortestPath, End);</span><br><span class="line">    shortestPath.Reverse();</span><br><span class="line">    <span class="keyword">return</span> shortestPath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BuildShortestPath</span>(<span class="params">List&lt;Node&gt; list, Node node</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.NearestToStart == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    list.Add(node.NearestToStart);</span><br><span class="line">    BuildShortestPath(list, node.NearestToStart);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DijkstraSearch</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Start.MinCostToStart = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> prioQueue = <span class="keyword">new</span> List&lt;Node&gt;();</span><br><span class="line">    prioQueue.Add(Start);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prioQueue = prioQueue.OrderBy(x =&gt; x.MinCostToStart).ToList();</span><br><span class="line">        <span class="keyword">var</span> node = prioQueue.First();</span><br><span class="line">        prioQueue.Remove(node);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> cnn <span class="keyword">in</span> node.Connections.OrderBy(x =&gt; x.Cost))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> childNode = cnn.ConnectedNode;</span><br><span class="line">            <span class="keyword">if</span> (childNode.Visited)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (childNode.MinCostToStart == <span class="literal">null</span> ||</span><br><span class="line">                node.MinCostToStart + cnn.Cost &lt; childNode.MinCostToStart)</span><br><span class="line">            &#123;</span><br><span class="line">                childNode.MinCostToStart = node.MinCostToStart + cnn.Cost;</span><br><span class="line">                childNode.NearestToStart = node;</span><br><span class="line">                <span class="keyword">if</span> (!prioQueue.Contains(childNode))</span><br><span class="line">                    prioQueue.Add(childNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node.Visited = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (node == End)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (prioQueue.Any());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是我的测试程序中随机生成的地图。点是节点，它们之间是代表边的线。该地图由 5000 个节点和 15000 条边组成。</p>
<p>搜索算法会访问较浅颜色的点，并以绿色绘制最佳路径。</p>
<p>A* 算法<br>Dijkstra 算法有很多改进。最常见的一种称为 A*。它与 Dijkstra 基本相同，只是做了一个简单的修改。</p>
<p>边缘的优先级还取决于该边缘与目标的直线距离有多近。因此，在运行 A* 搜索之前，必须测量每个节点到最终目的地的直线距离，如果您知道每个节点的坐标，这很容易。这是 A* 的最简单形式，它的定义还允许改进启发式函数。（在本例中为 StraightLineDistanceToEnd）</p>
<p>该算法具有很大的性能优势，因为当路径末端的方向已知时，它不需要访问尽可能多的节点。</p>
<p>请参阅下面的实现。以粗体显示添加到 Dijkstra 算法的内容。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Node&gt; <span class="title">GetShortestPathAstar</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> node <span class="keyword">in</span> Map.Nodes)</span><br><span class="line">        node.StraightLineDistanceToEnd = node.StraightLineDistanceTo(End);</span><br><span class="line">    AstarSearch();</span><br><span class="line">    <span class="keyword">var</span> shortestPath = <span class="keyword">new</span> List&lt;Node&gt;();</span><br><span class="line">    shortestPath.Add(End);</span><br><span class="line">    BuildShortestPath(shortestPath, End);</span><br><span class="line">    shortestPath.Reverse();</span><br><span class="line">    <span class="keyword">return</span> shortestPath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AstarSearch</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Start.MinCostToStart = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> prioQueue = <span class="keyword">new</span> List&lt;Node&gt;();</span><br><span class="line">    prioQueue.Add(Start);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prioQueue = prioQueue.OrderBy(x =&gt; x.MinCostToStart + x.StraightLineDistanceToEnd).ToList();</span><br><span class="line">        <span class="keyword">var</span> node = prioQueue.First();</span><br><span class="line">        prioQueue.Remove(node);</span><br><span class="line">        NodeVisits++;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> cnn <span class="keyword">in</span> node.Connections.OrderBy(x =&gt; x.Cost))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> childNode = cnn.ConnectedNode;</span><br><span class="line">            <span class="keyword">if</span> (childNode.Visited)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (childNode.MinCostToStart == <span class="literal">null</span> ||</span><br><span class="line">                node.MinCostToStart + cnn.Cost &lt; childNode.MinCostToStart)</span><br><span class="line">            &#123;</span><br><span class="line">                childNode.MinCostToStart = node.MinCostToStart + cnn.Cost;</span><br><span class="line">                childNode.NearestToStart = node;</span><br><span class="line">                <span class="keyword">if</span> (!prioQueue.Contains(childNode))</span><br><span class="line">                    prioQueue.Add(childNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node.Visited = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (node == End)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (prioQueue.Any());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是与上面相同的地图，但路径是使用 A* 算法计算的。如您所见，需要访问的节点要少得多。</p>
<p>结果<br>在 500,000 个节点的同一张地图上运行这两种算法时，我得到了这些结果。</p>
<pre><code>                                Dijkstra	                    A*
</code></pre>
<p>Visited nodes	    330,871	               19,410<br>Time to calculate (ms)        850	                   127<br>Cost of best path	     14,322	               22,994<br>Distance of shortest path 0,82446           0,82446</p>
<p>如上表所示，A* 算法比 Dijkstra 快 7 倍左右，并且它们都找到了最短路径。<br>但是，当为边的成本生成随机数时，Dijkstra 会找到一条成本更低的路径。<br>例如，在真实地图中，最短路径并不总是最好的。在限速较高的道路上行驶可能会让您更快到达目的地。这就是为什么在边的成本中添加一个随机数会使这个实验更加现实。</p>
<p>结论<br>那么 Dijkstra 和 A* 的最佳寻路算法是什么算法呢？<br>我会说这取决于。如果您只对最短路径感兴趣，那就是 A<em>。<br>它要快得多，并且给出与 Dijkstra 相同的结果。但是，如果边的成本还有其他方面而不是其长度，那么 Dijkstra 在找到最佳路径方面比这个版本的 A</em> 更好。毕竟，它仍然非常快。我认为 500,000 个节点是一个非常大的数据集。我也认为我的实现可以优化很多。</p>
<p>挑战<br>如果您还幼稚地喜欢编程挑战，也许您想对机器人进行编程以找到迷宫的出路？</p>
<p>您可能需要一些寻路算法来解决它。<br>请参阅此站点：  http :&#x2F;&#x2F;airobots.azurewebsites.net&#x2F;</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>微软</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言 快速概览</title>
    <url>/48578.html</url>
    <content><![CDATA[<p>在本文中，我们将快速概述 Google 的 Go 编程语言。</p>
<p>目录</p>
<ol>
<li>介绍</li>
<li>Go Hello, World!</li>
<li>注释</li>
<li>分号</li>
<li>功能<br> 入口点</li>
<li>变量<br> 短变量声明</li>
<li>内置类型</li>
<li>用户定义的类型<br> 结构<br> 界面</li>
<li>数组</li>
<li>切片</li>
<li>常数</li>
<li>指针</li>
<li>声明</li>
<li>匿名函数<br> 闭包</li>
<li>方法</li>
<li>参考</li>
<li>历史</li>
</ol>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Go 是一种由 Google 创建的通用编程语言。这是一个开源项目，旨在提高程序员的工作效率。Go 非常有表现力和干净。它的并发编程能力帮助程序员编写需要充分利用多核和联网机器的程序。Go 是静态类型和编译的编程语言。Go 将程序快速编译成机器代码。它还具有垃圾收集功能。垃圾收集使并发代码更容易编写。除此之外，Go 还有一个非常丰富的标准库。</p>
<span id="more"></span>
<p>Go Hello, World!<br>让我们看看下面的“你好，世界！” 用 Go 编写的程序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个 hello world 程序中，我们得到了以下内容：</p>
<ol>
<li>一个名为main的包名。但实际上它是什么？</li>
</ol>
<p>好吧，每个 Go 程序都是由包组成的。我们要么编写一个库，要么编写一个可执行程序。可执行程序属于包main。这意味着可执行程序开始在包main中运行。所以在一个 Go 程序的开头，需要通过以下方式指定包名：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br></pre></td></tr></table></figure>

<p>这将告诉编译器这个程序是一个可执行程序。不是图书馆。</p>
<p>但是如果我们写了一个库，这意味着我们正在写一个新的包，我们给这个包起个名字。假设我们的新库&#x2F;包名称将是‘simplelib’. 如果是这样，那么在我们新库&#x2F;包的每个源文件的开头，必须存在以下行：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simplelib</span><br></pre></td></tr></table></figure>
<p>这就是我们告诉编译器这个源文件属于包’ simplelib ‘的方式。</p>
<ol start="2">
<li>我们发现了一个 import 语句，它正在导入名为“ fmt ”的东西。</li>
</ol>
<p>import 语句用于将外部 Go 包导入另一个 Go 包&#x2F;程序。非常类似于 C 的 include 预处理器指令。</p>
<p>import 语句的使用方式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;package_name&quot;</span></span><br></pre></td></tr></table></figure>

<p>或者（在导入多个包时推荐使用此语法）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;package_name&quot;</span></span><br><span class="line">    <span class="string">&quot;package_name2&quot;</span></span><br><span class="line">    <span class="string">&quot;package_name3&quot;</span></span><br><span class="line">    <span class="string">&quot;package_nameN&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在 hello world 示例中，导入了一个名为fmt的包。包fmt使用类似于 Cprintf和scanf. “动词”格式源自 C，但更简单。所以这个包在与控制台窗口交互时是必需的。</p>
<ol start="3">
<li>一个名为 的用户定义函数main。</li>
</ol>
<p>这个函数类似于 C 的入口点main。Go 程序的代码执行从这个函数开始。</p>
<ol start="4">
<li>在main函数内部，另一个名为的函数Println被调用以打印“Hello, World!”。信息。</li>
</ol>
<p>该Println函数用于在控制台窗口上打印一些东西。这个函数属于 fmt 包，这就是为什么这个包是在 hello world 程序的一开始就被导入的。</p>
<p>GoPrintln非常有用。我们可以使用此函数打印字符串或整数等值。甚至，我们可以打印更复杂的东西，比如数组。我们不需要任何循环来打印数组的元素。该Println函数在打印所有值后自动插入换行符。</p>
<p>现在，我们将介绍 Go 编程语言的一些特性。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>我们程序员使用注释来描述一段代码。这使得代码更容易理解和阅读。Go 中的注释主要有两种形式：</p>
<p>单行注释<br>多行注释<br>以下是单行注释的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This is a single line comment.</span></span><br></pre></td></tr></table></figure>
<p>以下是多行注释的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is a multi line comment.</span></span><br><span class="line"><span class="comment">   This is the second line of this multi line comment.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>现在我们可以看到，在 Go 中做注释类似于 C++、C#、Java 等。</p>
<h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><p>与 C、C++、C#、Java 等编程语言不同，Go 中不需要使用分号来指示语句的终止。Go 的词法分析器使用一个简单的规则来推断语句的结尾。</p>
<p>惯用的 Go 程序仅在诸如 for 循环子句之类的地方使用分号来分隔初始值设定项、条件和延续元素。它们也是分隔一行中的多个语句所必需的。</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>在 Go 中，函数创建具有以下语法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">(input_parameter_list)</span></span> (return_type_list) &#123;</span><br><span class="line">    function_stataments</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到函数创建以 func 关键字开始。然后我们必须指定函数的名称。函数的名称应该是任何有效的 Go 标识符。之后，我们把所有的输入参数。如果一个函数的参数列表中有多个参数，则需要用逗号分隔。而且，参数必须由大括号()包围。然后我们指定函数的返回类型。但是如果我们的函数不需要返回任何值，那么我们可以省略返回类型。</p>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sing</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// I&#x27;m singing!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个在两个数字之间进行加法并将结果作为整数值返回的函数示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 C 不同，Go 中的函数可以有多个返回值，这是一个内置特性。在这种情况下，返回类型需要用大括号 ( ) 括起来，并且所有返回类型都必须通过逗号运算符分隔。</p>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getall</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>, <span class="string">&quot;that&#x27;s all!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而当我们调用该函数时，会通过这种方式获取多个返回值（本示例代码使用短变量声明形式，我们将在“短变量声明”部分讨论）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i, s := getall()</span><br></pre></td></tr></table></figure>

<p>现在变量i包含第一个返回值（即10）并且变量s包含第二个返回值（它是一个字符串并且是“就是这样！”）。</p>
<p>在 Go 中，这种多返回值特性通常用于从函数返回结果值和错误值。</p>
<p>入口点<br>一个名为 as 的全局函数main被识别为程序的入口点：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">    <span class="comment">// function’s body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，Go 的 main 函数没有用于访问命令行参数的参数（如 C 中的 ,​​ ）argc。argv但是，一个名为os的 Go 包提供了该问题的解决方案。os包的Args变量提供对原始命令行参数的访问。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(os.Args), os.Args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Go 中的变量声明具有以下语法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier_list类型</span><br><span class="line"><span class="keyword">var</span> identifier_list = initializer_expression_list</span><br><span class="line"><span class="keyword">var</span> identifier_list <span class="keyword">type</span> = initializer_expression_list</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> a, b, c <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> k = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span> = <span class="number">12</span>, <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到 Go 中的变量声明以var关键字开头。而且，并不总是需要明确指定类型。我们可以让编译器从初始化表达式中推断出变量的类型。这就像我们在 C++11 中使用auto关键字一样。</p>
<p>短变量声明<br>短变量声明具有以下语法，不需要在声明开头使用var关键字并自动推断变量的类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">identifier_list := initializer_expression_list</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a, b, c := <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>这使编码更容易，并有助于更快地编写代码。</p>
<p>请注意，短变量声明形式只能在函数内部使用。您不能在全局范围内使用它。</p>
<h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><p>以下是 Go 中可用的所有基本&#x2F;内置类型的列表：</p>
<p>bool - 由两个预定义的常量true和false组成<br>string - 表示字符序列<br>int8 - 有符号 8 位整数（-128 到 127）<br>int16 - 有符号 16 位整数（-32768 到 32767）<br>int32 - 有符号 32 位整数（-2147483648 到 2147483647）<br>int64 - 有符号 64 位整数（-9223372036854775808 到 9223372036854775807）<br>int - 带符号的 32 位或 64 位整数（取决于系统）<br>uint8 - 无符号 8 位整数（0 到 255）<br>uint16 - 无符号 16 位整数（0 到 65535）<br>uint32 - 无符号 32 位整数（0 到 4294967295）<br>uint64 - 无符号 64 位整数（0 到 18446744073709551615）<br>uint - 无符号 32 或 64 位整数（取决于系统）<br>uintptr - 无符号 32 或 64 位整数（取决于系统）<br>字节（uint8 的别名）<br>符文（ int32 的别名）<br>float32 - IEEE-754 32 位浮点数<br>float64 - IEEE-754 64 位浮点数<br>complex64 - 具有 float32 实部和虚部的复数<br>complex128 - 具有 float64 实部和虚部的复数<br>注意：int、uint和uintptr类型在 32 位系统上通常为 32 位宽，在 64 位系统上通常为 64 位宽。当您需要一个整数值时，您应该使用int，除非您有特定的理由使用一个大小调整或无符号整数类型。</p>
<h2 id="用户定义的类型"><a href="#用户定义的类型" class="headerlink" title="用户定义的类型"></a>用户定义的类型</h2><p>Go 中用户自定义类型主要有两种：</p>
<p>结构<br>界面<br>结构<br>结构允许程序员将多个相同或不同类型的变量保存在一起。</p>
<p>在 Go 中，需要使用type和struct关键字来创建结构。创建结构的语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> identifier <span class="keyword">struct</span> &#123;</span><br><span class="line">    structure_members</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由四个相同类型的变量组成的结构示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    left <span class="type">int</span></span><br><span class="line">    top <span class="type">int</span></span><br><span class="line">    right <span class="type">int</span></span><br><span class="line">    bottom <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由三个不同类型的变量组成的结构的另一个示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    income <span class="type">float32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构使用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rect Rectangle</span><br><span class="line"></span><br><span class="line">rect.left = <span class="number">20</span></span><br><span class="line">rect.top = <span class="number">10</span></span><br><span class="line">rect.right = <span class="number">50</span></span><br><span class="line">rect.bottom = <span class="number">60</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;left: &quot;</span>, rect.left)</span><br><span class="line">fmt.Println(<span class="string">&quot;top: &quot;</span>, rect.top)</span><br><span class="line">fmt.Println(<span class="string">&quot;right: &quot;</span>, rect.right)</span><br><span class="line">fmt.Println(<span class="string">&quot;bottom: &quot;</span>, rect.bottom)</span><br></pre></td></tr></table></figure>
<p>Go 允许在变量声明期间初始化结构的成员：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = Rectangle&#123;<span class="number">20</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">60</span>&#125;</span><br></pre></td></tr></table></figure>
<p>界面<br>Go 中接口的语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> identifier <span class="keyword">interface</span> &#123;</span><br><span class="line">    interface_methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">    Name() <span class="type">string</span></span><br><span class="line">    Age() <span class="type">int</span></span><br><span class="line">    Flee()</span><br><span class="line">    Die()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个使用接口的实际示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Greeting <span class="keyword">interface</span> &#123;</span><br><span class="line">    Say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> EngGreeting <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Implement the Greeting interface.</span></span><br><span class="line">    Greeting</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BanGreeting <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Implement the Greeting interface.</span></span><br><span class="line">    Greeting</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e * EngGreeting)</span></span> Say() &#123;</span><br><span class="line">    <span class="comment">// Implement method Say for EngGreeting struct.</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello Forhad Reja&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e * BanGreeting)</span></span> Say() &#123;</span><br><span class="line">    <span class="comment">// Implement method Say for BanGreeting struct.</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;ওহে ফরহাদ রেজা&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function doesn&#x27;t care whether &#x27;g&#x27; will be a Bengali or English greeting ;)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(g Greeting)</span></span> &#123;</span><br><span class="line">    g.Say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// create an instance of EngGreeting.</span></span><br><span class="line">    e := <span class="built_in">new</span>(EngGreeting)</span><br><span class="line">    say(e)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create an instance of BanGreeting.</span></span><br><span class="line">    b := <span class="built_in">new</span>(BanGreeting)</span><br><span class="line">    say(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>Go 中的数组创建语法与 C++、C# 等编程语言略有不同。方括号放在元素类型之前：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[ array_length_expression ] element_type</span><br></pre></td></tr></table></figure>
<p>数组长度表达式必须是大于零的整数常量。</p>
<p>创建单维和多维数组的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ar [<span class="number">10</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> mat [<span class="number">4</span>][<span class="number">4</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> big [<span class="number">10</span>][<span class="number">10</span>][<span class="number">10</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure>
<p>数组可以在创建时初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ar = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">12</span>, <span class="number">10</span>, <span class="number">32</span>&#125;</span><br></pre></td></tr></table></figure>
<p>让我们看一个为数组的单个元素赋值的例子。请注意，数组的索引从 0 开始，最后一个索引比数组的总长度小一：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ar[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">mat[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>访问数组的单个元素：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(ar[<span class="number">0</span>], mat[<span class="number">0</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>Go 中没有内置的动态数组。但是等等……有切片。</p>
<p>切片允许我们动态增加数组的大小。在 Go 中可以使用以下语法创建切片：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[  ] element_type</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> da []<span class="type">int</span> = []<span class="type">int</span>&#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(da)</span><br></pre></td></tr></table></figure>
<p>打印输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">9</span> <span class="number">8</span> <span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<p>Go 具有对切片&#x2F;动态数组执行操作的内置函数。这是使用内置append函数向数组添加新项目的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">da = <span class="built_in">append</span>(da, <span class="number">4</span>)</span><br><span class="line">fmt.Println(da)</span><br></pre></td></tr></table></figure>
<p>现在它打印：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h2 id="常数"><a href="#常数" class="headerlink" title="常数"></a>常数</h2><p>常量是在程序执行期间无法更改的固定值。常量声明以const关键字开头。语法类似于变量声明的语法，只是将var关键字替换为const关键字：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi <span class="type">float64</span> = <span class="number">3.14159265358979323846</span></span><br><span class="line"><span class="keyword">const</span> zero = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	size <span class="type">int64</span> = <span class="number">1024</span></span><br><span class="line">	eof        = <span class="number">-1</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> a, b, c = <span class="number">3</span>, <span class="number">4</span>, <span class="string">&quot;foo&quot;</span></span><br><span class="line"><span class="keyword">const</span> u, v <span class="type">float32</span> = <span class="number">0</span>, <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>与 C、C++ 一样，Go 支持指针。我们可以创建指针变量来保存另一个变量的地址。并且通过指针变量，我们可以给原来的变量赋值。&amp;运算符用于获取变量的地址，星号*运算符用于取消引用。</p>
<p>要创建具有显式类型的指针变量，必须将“ * ”符号放在类型名称之前。</p>
<p>创建具有显式类型的指针变量的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span></span><br></pre></td></tr></table></figure>
<p>用法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create a value type variable</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">42</span></span><br><span class="line"><span class="comment">// let’s get the address of the variable ‘n’</span></span><br><span class="line">p = &amp;n</span><br><span class="line"><span class="comment">// now, through the pointer variable ‘p’, assign 10 to the variable ‘n’</span></span><br><span class="line">*p = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>现在，如果我们打印变量 的值n，我们将得到10。</p>
<p>我们还可以使用短变量声明形式创建指针：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p := &amp;n</span><br></pre></td></tr></table></figure>
<p>需要注意的一点是，Go 没有指针算法。这意味着您不能简单地执行类似p++or的操作p +&#x3D; 1。</p>
<p>所以下面的语句：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p++</span><br></pre></td></tr></table></figure>
<p>会产生这个错误：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">invalid operation: p++ (non-numeric <span class="keyword">type</span> *<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>Go中有很多种语句。我们将讨论其中的几个。</p>
<p>If&#x2F;Else 语句</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_expression &#123;</span><br><span class="line">	<span class="comment">// if body</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// else body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if&#x2F;else语句在条件下起作用。如果给定条件表达式的计算结果为真，则执行“ if ”主体的代码，否则，如果存在，则执行“ else ”主体的代码。</p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">7</span>%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;7 is even&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;7 is odd&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用 ‘ if ‘ 而不使用 ‘ else ‘。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> age == <span class="number">12</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;too young&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，Go 中的条件不需要括号，而 C++、C#、Java 等编程语言通常需要。而且，Go 中没有三元运算符。即使是基本条件，您也必须使用完整的 if 语句。</p>
<p>对于声明</p>
<p>for是 Go 唯一的循环语句。Go中没有这样的 while、do-while、foreach等循环语句。虽然，Go 的 for 语句可以涵盖所有这些。</p>
<p>以下是for语句的最简单形式，其工作方式与 while 循环语句类似：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="number">10</span> &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典的初始&#x2F;条件&#x2F;之后 for 循环：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是带有范围子句的 for 语句的另一种形式。此表单用于迭代切片或映射：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ar := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> ar &#123;</span><br><span class="line">   fmt.Printf(i, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在切片上进行测距时，每次迭代都会返回两个值。第一个是索引，第二个是该索引处元素的副本。</p>
<p>切换语句</p>
<p>Go 的switch语句与 C++ 的 switch 语句非常相似，只是每个 case 主体都会自动中断。不需要显式地放置一个break语句：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> age &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Kid&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Teen&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Why are you?&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然，可以使用 fallthrough 语句将一个案例转移到下一个案例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> age &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Kid&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Teen&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Why are you?&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>延迟声明</p>
<p>defer语句用于调用不会立即执行的函数。而是将执行推迟到周围函数返回的那一刻。defer 语句通常用于简化执行各种清理操作的函数。</p>
<p>让我们看一个 defer 语句如何工作的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Hoorraa!… I’m deferred!&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Yeah… I’m also deferred!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Stop deferring!&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印以下内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Stop deferring!</span><br><span class="line">Yeah… I’m also deferred!</span><br><span class="line">Hoorraa!… I’m deferred!</span><br></pre></td></tr></table></figure>
<p>现在我们可以看到执行顺序完全颠倒了。这就是 defer 语句的实际工作方式。最后一个延迟函数调用在周围函数返回时首先执行。</p>
<p>另一个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Print(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>Go 语言支持匿名函数。当我们想要创建没有名称的函数时，匿名函数很有用！它们通常被称为 lambda 函数或简称为lambda。</p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// put a function into variable ‘greeting’</span></span><br><span class="line">greeting := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let’s invoke the function</span></span><br><span class="line">greeting()</span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>Go 的匿名函数可以形成闭包。闭包是一个函数值，它从其主体外部引用变量。该函数可以访问并分配给引用的变量；从这个意义上说，函数与变量“绑定”。</p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	num := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		num += x</span><br><span class="line">		<span class="keyword">return</span> num</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pos, neg := adder(), adder()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(pos(i), neg(-i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Go 没有课程。但是，我们可以在结构类型上定义方法。方法基本上是具有特殊接收器参数的函数。接收器参数出现在其自己的参数列表中，位于func关键字和方法名称之间。</p>
<p>在下面的示例中，我们将为结构实现两个名为width和height的方法Rectangle：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    left <span class="type">int</span></span><br><span class="line">    top <span class="type">int</span></span><br><span class="line">    right <span class="type">int</span></span><br><span class="line">    bottom <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rectangle)</span></span> width() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.right - r.left</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> height() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.bottom - r.top</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := Rectangle&#123;<span class="number">20</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;width: &quot;</span>, r.width())</span><br><span class="line">    fmt.Println(<span class="string">&quot;height: &quot;</span>, r.height())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">width: <span class="number">30</span></span><br><span class="line">height: <span class="number">40</span></span><br></pre></td></tr></table></figure>
<p>我们可以使用值类型或指针类型作为接收器参数。Go 自动处理方法调用的值和指针之间的转换。不过，您可能希望使用指针接收器类型来避免复制方法调用或允许该方法修改接收结构的数据。</p>
<p>参考<br><a href="https://golang.org/">https://golang.org</a><br><a href="https://tour.golang.org/">https://tour.golang.org</a><br><a href="https://gobyexample.com/">https://gobyexample.com</a></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>微软</tag>
      </tags>
  </entry>
  <entry>
    <title>p20220805</title>
    <url>/176.html</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">C1</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fun f1()</span><br><span class="line"> a();</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>U++ 2022.2 入门</title>
    <url>/56409.html</url>
    <content><![CDATA[<p>安装及初看U++平台<br>本文提供有关 U++ 环境的基本信息以及在您的计算机上安装它所需的步骤。<br>目录</p>
<ol>
<li>我为什么要在乎？</li>
<li>在哪里下载</li>
<li>Linux、FreeBSD 和 OpenSolaris 安装</li>
<li>OpenBSD 特定说明</li>
<li>视窗</li>
<li>苹果系统</li>
<li>选择主包对话框</li>
<li>尝试第一个示例</li>
<li>将 TheIDE 安装到 Linux 桌面菜单中</li>
<li>如何启动新项目</li>
<li>UppHub</li>
<li>接下来是什么</li>
</ol>
<span id="more"></span>

<h2 id="我为什么要在乎？"><a href="#我为什么要在乎？" class="headerlink" title="我为什么要在乎？"></a>我为什么要在乎？</h2><p>U++ 是一个开源 C++ 框架&#x2F;开发环境，目前最适合具有雄心勃勃的项目的小型团队，这些项目可以做“真正的事情”，例如设计建筑物的工程应用程序、风电场模拟、销售点终端、SQL 客户端-服务器办公室议程、业务销售或复杂的网站后端（是的，我在这里列出了真实世界的示例）。然而，它也可以从最小的实用程序中很好地扩展，正如可以在此处看到的那样。</p>
<p>它是围绕一些相当极端的原则设计的，以最大限度地提高开发人员的生产力和性能。</p>
<p>虽然 C++ 语言的复杂性无法抽象出来（但绝对是实现生产力和性能目标所必需的），但有经验的 U++ 程序员可能会发现自己在 U++ 中执行任务比使用“易于使用”的脚本语言（如 Python）更有效率，是我们的最终目标。</p>
<p>同时，U++ 核心库在字符串操作和映射等领域提供的性能比标准 C++ 库高约 3 倍，这些领域在许多场景中都包含大量负载（例如处理 JSON 或解析文件）。</p>
<p>最重要的是源代码的模块化系统和相应的构建系统，这使得大型项目的管理变得更加简单。</p>
<p>一个事实总结一下：完全重建 U++ 开发环境(TheIDE) 和调试模式下的所有框架库只需要45 秒。（您实际上可以在安装后立即尝试，因为 TheIDE 源是发行版的一部分）。</p>
<p>它在一个演示示例中也有一张漂亮的猫图片！</p>
<p>U++ 目前适用于Windows、X11和MacOS平台。</p>
<h2 id="在哪里下载"><a href="#在哪里下载" class="headerlink" title="在哪里下载"></a>在哪里下载</h2><p>稳定版本可以在<a href="https://sourceforge.net/projects/upp/%E6%89%BE%E5%88%B0%E3%80%82">https://sourceforge.net/projects/upp/找到。</a></p>
<p>U++ 目前作为 LZMA 压缩档案发布（.7z 用于 Windows，.xz 用于 POSIX &#x2F; MacOS）。</p>
<h2 id="Linux、FreeBSD-和-OpenSolaris-安装"><a href="#Linux、FreeBSD-和-OpenSolaris-安装" class="headerlink" title="Linux、FreeBSD 和 OpenSolaris 安装"></a>Linux、FreeBSD 和 OpenSolaris 安装</h2><p>在 Linux 中，必须为目标发行版编译 U++，同时满足依赖关系。然而，对于大多数流行的 Linux 风格来说，这个过程是快速的并且大部分是自动化的。解压存档后，cd到upp文件夹并运行.&#x2F;install脚本：<br><img src="/pic/u2022080101.png" alt="img"><br>该脚本应该能够检测您的 Linux 发行版并建议安装所需依赖项的命令。如果您不介意共享 sudo 密码，它甚至可以安装这些，或者您可以将命令复制到单独的终端并自己运行。.&#x2F;install对于 FreeBSD 和 OpenSolaris 派生系统，相同的过程也应该可以正常工作。</p>
<p>之后，将从源代码编译开发环境，这在现代 x86 CPU 上需要几分钟（在 Raspberry PI 4 上大约需要 15 分钟）：<br><img src="/pic/u2022080102.png" alt="img"><br>之后，.&#x2F;theide生成二进制文件，可以立即使用脚本启动它，您应该会看到如下内容：<br><img src="/pic/u2022080103.png" alt="img"><br>注意：除非您将ide 二进制文件移到其他地方，否则它不会在upp目录之外写入任何内容。一旦你对 U++ 感到厌烦，就删除upp。</p>
<p>此后，在所有平台上使用 TheIDE 基本相同。</p>
<h2 id="OpenBSD-特定说明"><a href="#OpenBSD-特定说明" class="headerlink" title="OpenBSD 特定说明"></a>OpenBSD 特定说明</h2><p>在 OpenBSD 中，您需要在运行.&#x2F;install脚本之前手动解决依赖关系，方法是运行：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pkg_add bash pkgconfig</span><br></pre></td></tr></table></figure>
<p>（只要您在安装 U++ 之前安装了桌面环境，这应该可以工作。）</p>
<p>还需要将&#x2F;etc&#x2F;login.conf中允许的内存大小增加到：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span>:\</span><br><span class="line">    :datasize-max=<span class="number">4096</span>M:\</span><br><span class="line">    :datasize-cur=<span class="number">4096</span>M:\</span><br><span class="line">    :stacksize-cur=<span class="number">512</span>M:\</span><br></pre></td></tr></table></figure>
<p>否则编译器将耗尽内存。之后，按照 Linux 的说明进行操作。</p>
<h2 id="视窗"><a href="#视窗" class="headerlink" title="视窗"></a>视窗</h2><p>在 Windows 中，TheIDE 是预编译的，U++ 带有所有需要的依赖项，包括 clang 编译器。只需解压缩存档并启动theide.exe 即可。<br><img src="/pic/u2022080104.png" alt="img"><br>再一次，U++ 是自包含的，不会在upp目录之外写入任何内容。启动theide.exe后，您应该会看到与 Linux 基本相同的对话框：<br><img src="/pic/u2022080105.png" alt="img"></p>
<h2 id="苹果系统"><a href="#苹果系统" class="headerlink" title="苹果系统"></a>苹果系统</h2><p>在 MacOS 中，TheIDE 在存档中预编译，但是 U++ 需要 C++ 工具链来构建应用程序。您可以在此处找到有关如何安装工具链的说明，例如。</p>
<p>可以使用homebrew安装其他一些工具和库。建议使用以下软件包（因为在某些情况下可能需要它们）：openssl, libssh2.</p>
<p>要启动 TheIDE，您只需从解压缩的存档中启动theide.app：<br><img src="/pic/u2022080106.png" alt="img"><br>您现在应该看到与其他平台上基本相同的对话框：<br><img src="/pic/u2022080107.png" alt="img"></p>
<h2 id="选择主包对话框"><a href="#选择主包对话框" class="headerlink" title="选择主包对话框"></a>选择主包对话框</h2><p>无需赘述，我们现在将描述您在对话框中看到的内容。</p>
<p>程序集基本上是用于查找源代码模块的目录列表。此类模块的术语是package。包基本上是一个目录，其中包含 C++ 源文件和一些描述如何编译包和对其他包的依赖关系的元信息。</p>
<p>您在对话框中看到的程序集列表是可编辑的，但在您第一次启动 TheIDE 后，它会根据发行版附带的源创建一组预定义的程序集。在这里，examples主要包含更复杂的演示示例来“展示 U++ 的力量”（以及一些猫图片），同时reference包含近 200 个演示 U++ 框架各个方面的示例。tutorial是 U++ 网站上的几个多步骤教程附带的示例。uppsrc是包含基本 U++ 库和实用程序以及 TheIDE 本身的源代码的程序集。MyApps是为您使用 U++ 进行初始实验而准备的程序集。</p>
<p>除了“规范”模块外，U++ 版本还带有大量社区贡献的内容，称为bazaar. 目前，集市代码的质量和实用性差异很大，因此请谨慎使用。是这些包的演示示例，而您的项目是否已准备好包含包的程序集。 examples-bazaarMyApps-bazaarbazaar</p>
<h2 id="尝试第一个示例"><a href="#尝试第一个示例" class="headerlink" title="尝试第一个示例"></a>尝试第一个示例</h2><p>现在让我们加载、编译和运行其中一个示例。选择examples并在包列表中选择Days（当然，您可以选择任何其他示例，但Days以下屏幕截图所示）。TheIDE 将加载项目，您应该会看到：<br><img src="/pic/u2022080108.png" alt="img"><br>在左上角，有一个包列表。Days是您选择的包（它是主包），列出的其他包是它的直接或间接依赖项。在该列表区域下是当前选定包的文件列表。请注意，这意味着 U++ 项目的所有源文件，包括 U++ 框架的所有源文件，通常只需单击 2 次鼠标即可（实际上您必须小心不要通过编辑它们来损坏框架文件）。</p>
<p>窗口的中心显然包含当前文件的源代码。右边是一个叫做“导航器”的东西——这是一个基于C++源代码分析整个项目的搜索工具。</p>
<p>要编译并运行项目，请按Ctrl+F5或在Debug菜单中选择“ Execute ” 。<br><img src="/pic/u2022080109.png" alt="img"><br>整个项目现在将编译并启动应用程序。<br><img src="/pic/u2022080110.png" alt="img"><br>注意：第一次这样做时，对于给定的配置，U++ 将需要编译整个框架，因此预计最多需要一分钟才能完成。仅对主包进行更改后的下一次编译应该会快得多。</p>
<h2 id="将-TheIDE-安装到-Linux-桌面菜单中"><a href="#将-TheIDE-安装到-Linux-桌面菜单中" class="headerlink" title="将 TheIDE 安装到 Linux 桌面菜单中"></a>将 TheIDE 安装到 Linux 桌面菜单中</h2><p>本部分仅适用于 Linux。现在运行 TheIDE，现在是通过调用此菜单项将其安装到桌面菜单的好时机：<br><img src="/pic/u2022080111.png" alt="img"><br>这将创建 ~&#x2F; .local&#x2F;share&#x2F;applications&#x2F;theide.desktop文件，该文件应将 TheIDE 带入Linux 桌面的Programming子菜单。</p>
<h2 id="如何启动新项目"><a href="#如何启动新项目" class="headerlink" title="如何启动新项目"></a>如何启动新项目</h2><p>要开始编写自己的代码，您应该选择MyApps程序集，它被重新配置为将您新创建的包放入MyApps目录。<br><img src="/pic/u2022080112.png" alt="img"><br>现在按下“新建包”按钮，您将进入“创建新包”小向导。<br><img src="/pic/u2022080113.png" alt="img"><br>对于这个测试，我们将选择U++ Basic CtrlLib 应用程序，这基本上意味着没有主窗口类的预生成代码的 GUI 应用程序。所以它只是向我们的主包添加了正确的依赖项，并提供了非常少的样板代码。为了结束讲座，我们现在要做的就是插入：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PromptOK</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>进入GUI_APP_MAIN区块：<br><img src="/pic/u2022080114.png" alt="img"><br>Execute并像Days示例一样调用“ ”：<br><img src="/pic/u2022080115.png" alt="img"><br>恭喜，您刚刚编译了您的第一个 U++ 应用程序！</p>
<h2 id="UppHub"><a href="#UppHub" class="headerlink" title="UppHub"></a>UppHub</h2><p>U++ 2021.1 的新特性是UppHub，该系统允许将 3rd 方模块（库）与 U++ 项目轻松集成。这类似于包管理系统，如 PyPI（用于 Python）、NuGet（用于 C#）或 vcpkg（用于 C&#x2F;C++）。由于现有的 U++ 模块化系统，在 TheIDE 中的集成非常无缝。</p>
<p>通过包选择对话框中的按钮访问 UppHub 对话框<br><img src="/pic/u2022080116.png" alt="img"><br>或通过菜单项 Setup &#x2F; UppHub..<br><img src="/pic/u2022080117.png" alt="img"><br>安装按钮将源存储库克隆到对 U++ 包系统可见的位置，从而可以立即在项目中使用已安装的包。在此处查看完整的 UppHub 文档。</p>
<h2 id="接下来是什么"><a href="#接下来是什么" class="headerlink" title="接下来是什么"></a>接下来是什么</h2><p>如果您一直关注到这里，那么您可能会对 U++ 稍微感兴趣并想知道下一步该做什么。好吧，更熟悉 U++ 的推荐路径是检查并尝试参考示例：<br><img src="/pic/u2022080118.png" alt="img"></p>
<p>这些是小代码片段，展示了 U++ 框架的大多数方面，因为它们打算被使用。只需浏览列表，加载您感兴趣的内容并运行它。当然，还有一个包含文档、教程和论坛的网站，人们渴望用 U++ 解决您的所有问题。</p>
<h2 id="有用的链接"><a href="#有用的链接" class="headerlink" title="有用的链接"></a>有用的链接</h2><p>U++主页<br><a href="http://www.ultimatepp.org/">http://www.ultimatepp.org/</a><br>U++下载页面<br><a href="https://sourceforge.net/projects/upp/files/upp/2022.2/">https://sourceforge.net/projects/upp/files/upp/2022.2/</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>U++</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL Index Manager – 用于 SQL Server 和 Azure 上的索引维护的免费 G​​UI 工具</title>
    <url>/8193.html</url>
    <content><![CDATA[<p>适用于 SQL Server 和 Azure 的开源索引维护工具<br>本文评估了我针对 SQL Server 和 Azure 的免费索引维护工具的设计方法：SQL 索引管理器。文章分析了 RedGate SQL Index Manager (v1.1.9.1378) 和 DevArt - dbForge Index Manager for SQL Server (v1.10.38) 的方法，并探讨了为什么我的工具将扫描分为两部分。最初，一个大的请求通过过滤那些不包含在过滤范围内的分区来预先确定分区的大小，然后，我们只获取那些包含数据的分区，以避免对空索引进行不必要的读取。</p>
<p><a href="https://www.codeproject.com/KB/Articles/5162340/SQLIndexManager.zip">Download SQL Index Manager v1.0.0.69 </a>(latest)</p>
<p><a href="https://www.codeproject.com/KB/Articles/5162340/SQLIndexManagerSource_v1.0.0.68.zip">Download source code</a> - 16.3 MB</p>
<p><a href="https://www.codeproject.com/KB/Articles/5162340/SQLIndexManager_v1.0.0.68.zip">Download SQL Index Manager v1.0.0.68</a> - 16.2 MB</p>
<p><a href="https://www.codeproject.com/KB/Articles/5162340/SQLIndexManager_v1.0.0.67.zip">Download SQL Index Manager v1.0.0.67</a> - 16.2 MB</p>
<p>介绍<br>作为一名 SQL Server DBA，我已经工作了 8 年多，负责管理和优化服务器的性能。在我的空闲时间，我想为宇宙和我的同事做一些有用的事情。这就是我们最终获得用于 SQL Server 和 Azure的免费索引维护工具的方式。</p>
<p>主意<br>每隔一段时间，人们在处理他们的优先事项时，就会像一个手指型电池——一次激励性的充电只持续一次闪光，然后一切都消失了。直到最近，我在这个生命观察中也不例外。我经常被创造自己的东西的想法所困扰，但是优先级从一个到另一个，什么都没有完成。</p>
<p>DevArt 开发了用于开发和管理 SQL Server、MySQL 和 Oracle 数据库的软件，对我的动力和职业发展产生了重大影响。</p>
<p>在来找他们之前，我对创建自己的产品的具体细节知之甚少，但在这个过程中，我获得了很多关于 SQL Server 内部结构的知识。一年多以来，一直在他们的产品线中进行查询优化，我逐渐开始了解市场上哪个功能比另一个更需要。</p>
<p>到了某个阶段，我就有了做一个新的小众产品的想法，但由于某些情况，这个想法没有成功。那个时候，基本没能在公司内部找到足够的资源，在不影响核心业务的情况下进行新项目。</p>
<p>在一个全新的地方工作并尝试自己创建一个项目让我不断妥协。最初的想法是制作一个花里胡哨的大产品，很快就停止了，并逐渐转变为一个不同的方向——将计划的功能分解为单独的迷你工具，并相互独立地实现它们。</p>
<p>于是，<a href="https://github.com/sergeysyrovatchenko/SQLIndexManager">SQL 索引管理器</a>诞生了，它是 SQL Server 和 Azure 的免费索引维护工具。主要想法是以 RedGate 和 Devart 公司的商业替代品为基础，并尝试在我自己的项目中改进其功能。</p>
<p><img src="/pic/sql2022080201.png" alt="img"><br><img src="/pic/sql2022080202.png" alt="img"></p>
<p>执行<br>从口头上讲，一切听起来都很简单……只需观看一些激励视频，打开“Rocky Balboa”模式，然后开始制作很酷的产品。但是让我们面对音乐，一切都不是那么美好，因为在使用系统表功能时有很多陷阱，sys.dm_db_index_physical_stats同时，它是唯一可以从中获取有关索引碎片的最新信息的地方.</p>
<p>从开发的最初几天开始，就有一个很好的机会在标准方案中创造一种沉闷的方式，并复制竞争应用程序已经调试过的逻辑，同时添加一些即兴发挥。但是在分析元数据查询之后，我想做一些更优化的事情，由于大公司的官僚主义，这些东西永远不会出现在他们的产品中。</p>
<p>在分析<a href="https://www.red-gate.com/products/dba/sql-index-manager/">RedGate SQL 索引管理器</a>（v1.1.9.1378 - 每个用户 155 美元）时，您可以看到应用程序使用了一种非常简单的方法：使用第一个查询，我们得到一个用户表和视图的列表，然后在第二个查询之后一，我们返回所选数据库中所有索引的列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT objects.name AS tableOrViewName</span><br><span class="line">     , objects.object_id AS tableOrViewId</span><br><span class="line">     , schemas.name AS schemaName</span><br><span class="line">     , CAST(ISNULL(lobs.NumLobs, 0) AS BIT) AS ContainsLobs</span><br><span class="line">     , o.is_memory_optimized</span><br><span class="line">FROM sys.objects AS objects</span><br><span class="line">JOIN sys.schemas AS schemas ON schemas.schema_id = objects.schema_id</span><br><span class="line">LEFT JOIN (</span><br><span class="line">    SELECT object_id</span><br><span class="line">         , COUNT(*) AS NumLobs</span><br><span class="line">    FROM sys.columns WITH (NOLOCK)</span><br><span class="line">    WHERE system_type_id IN (34, 35, 99)</span><br><span class="line">        OR max_length = -1</span><br><span class="line">    GROUP BY object_id</span><br><span class="line">) AS lobs ON objects.object_id = lobs.object_id</span><br><span class="line">LEFT JOIN sys.tables AS o ON o.object_id = objects.object_id</span><br><span class="line">WHERE objects.type = &#x27;U&#x27;</span><br><span class="line">    OR objects.type = &#x27;V&#x27;</span><br><span class="line"></span><br><span class="line">SELECT i.object_id AS tableOrViewId</span><br><span class="line">     , i.name AS indexName</span><br><span class="line">     , i.index_id AS indexId</span><br><span class="line">     , i.allow_page_locks AS allowPageLocks</span><br><span class="line">     , p.partition_number AS partitionNumber</span><br><span class="line">     , CAST((c.numPartitions - 1) AS BIT) AS belongsToPartitionedIndex</span><br><span class="line">FROM sys.indexes AS i</span><br><span class="line">JOIN sys.partitions AS p ON p.index_id = i.index_id</span><br><span class="line">                        AND p.object_id = i.object_id</span><br><span class="line">JOIN (</span><br><span class="line">    SELECT COUNT(*) AS numPartitions</span><br><span class="line">         , object_id</span><br><span class="line">         , index_id</span><br><span class="line">    FROM sys.partitions</span><br><span class="line">    GROUP BY object_id</span><br><span class="line">           , index_id</span><br><span class="line">) AS c ON c.index_id = i.index_id</span><br><span class="line">      AND c.object_id = i.object_id</span><br><span class="line">WHERE i.index_id &gt; 0 -- ignore heaps</span><br><span class="line">    AND i.is_disabled = 0</span><br><span class="line">    AND i.is_hypothetical = 0</span><br></pre></td></tr></table></figure>
<p>接下来，在while每个索引分区的循环中，发送一个请求以确定其大小和碎片级别。在扫描结束时，重量小于条目阈值的索引会显示在客户端上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXEC sp_executesql N&#x27;</span><br><span class="line">SELECT index_id, avg_fragmentation_in_percent, page_count</span><br><span class="line">FROM sys.dm_db_index_physical_stats(@databaseId, @objectId, @indexId, @partitionNr, NULL)&#x27;</span><br><span class="line">    , N&#x27;@databaseId int,@objectId int,@indexId int,@partitionNr int&#x27;</span><br><span class="line">    , @databaseId = 7, @objectId = 2133582639, @indexId = 1, @partitionNr = 1</span><br><span class="line"></span><br><span class="line">EXEC sp_executesql N&#x27;</span><br><span class="line">SELECT index_id, avg_fragmentation_in_percent, page_count</span><br><span class="line">FROM sys.dm_db_index_physical_stats(@databaseId, @objectId, @indexId, @partitionNr, NULL)&#x27;</span><br><span class="line">    , N&#x27;@databaseId int,@objectId int,@indexId int,@partitionNr int&#x27;</span><br><span class="line">    , @databaseId = 7, @objectId = 2133582639, @indexId = 2, @partitionNr = 1</span><br><span class="line"></span><br><span class="line">EXEC sp_executesql N&#x27;</span><br><span class="line">SELECT index_id, avg_fragmentation_in_percent, page_count</span><br><span class="line">FROM sys.dm_db_index_physical_stats(@databaseId, @objectId, @indexId, @partitionNr, NULL)&#x27;</span><br><span class="line">    , N&#x27;@databaseId int,@objectId int,@indexId int,@partitionNr int&#x27;</span><br><span class="line">    , @databaseId = 7, @objectId = 2133582639, @indexId = 3, @partitionNr = 1</span><br></pre></td></tr></table></figure>
<p>在分析此应用程序的逻辑时，您可能会发现各种缺点。例如，在发送请求之前，不会检查当前分区是否包含任何行以将空分区排除在扫描之外。</p>
<p>但问题在另一个方面表现得更加明显——对服务器的请求数将大约等于从sys.partitions. 鉴于真实数据库可能包含数万个分区，这种细微差别可能会导致向服务器发送大量类似请求。在数据库位于远程服务器的情况下，由于每个请求的执行增加了网络延迟，即使是最简单的请求，扫描时间也会更长。</p>
<p><a href="https://www.devart.com/dbforge/sql/index-manager/">与 RedGate 不同的是，由 DevArt 开发的用于 SQL Server</a>的类似产品dbForge Index Manager （v1.10.38 - 每用户 99 美元）在一个大型查询中接收信息，然后在客户端上显示所有内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT SCHEMA_NAME(o.[schema_id]) AS [schema_name]</span><br><span class="line">     , o.name AS parent_name</span><br><span class="line">     , o.[type] AS parent_type</span><br><span class="line">     , i.name</span><br><span class="line">     , i.type_desc</span><br><span class="line">     , s.avg_fragmentation_in_percent</span><br><span class="line">     , s.page_count</span><br><span class="line">     , p.partition_number</span><br><span class="line">     , p.[rows]</span><br><span class="line">     , ISNULL(lob.is_lob_legacy, 0) AS is_lob_legacy</span><br><span class="line">     , ISNULL(lob.is_lob, 0) AS is_lob</span><br><span class="line">     , CASE WHEN ds.[type] = &#x27;PS&#x27; THEN 1 ELSE 0 END AS is_partitioned</span><br><span class="line">FROM sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, NULL) s</span><br><span class="line">JOIN sys.partitions p ON s.[object_id] = p.[object_id]</span><br><span class="line">                     AND s.index_id = p.index_id</span><br><span class="line">                     AND s.partition_number = p.partition_number</span><br><span class="line">JOIN sys.indexes i ON i.[object_id] = s.[object_id]</span><br><span class="line">                  AND i.index_id = s.index_id</span><br><span class="line">LEFT JOIN (</span><br><span class="line">    SELECT c.[object_id]</span><br><span class="line">         , index_id = ISNULL(i.index_id, 1)</span><br><span class="line">         , is_lob_legacy = MAX(CASE WHEN c.system_type_id IN (34, 35, 99) THEN 1 END)</span><br><span class="line">         , is_lob = MAX(CASE WHEN c.max_length = -1 THEN 1 END)</span><br><span class="line">    FROM sys.columns c</span><br><span class="line">    LEFT JOIN sys.index_columns i ON c.[object_id] = i.[object_id]</span><br><span class="line">                                 AND c.column_id = i.column_id</span><br><span class="line">                                 AND i.index_id &gt; 0</span><br><span class="line">    WHERE c.system_type_id IN (34, 35, 99)</span><br><span class="line">        OR c.max_length = -1</span><br><span class="line">    GROUP BY c.[object_id], i.index_id</span><br><span class="line">) lob ON lob.[object_id] = i.[object_id]</span><br><span class="line">     AND lob.index_id = i.index_id</span><br><span class="line">JOIN sys.objects o ON o.[object_id] = i.[object_id]</span><br><span class="line">JOIN sys.data_spaces ds ON i.data_space_id = ds.data_space_id</span><br><span class="line">WHERE i.[type] IN (1, 2)</span><br><span class="line">    AND i.is_disabled = 0</span><br><span class="line">    AND i.is_hypothetical = 0</span><br><span class="line">    AND s.index_level = 0</span><br><span class="line">    AND s.alloc_unit_type_desc = &#x27;IN_ROW_DATA&#x27;</span><br><span class="line">    AND o.[type] IN (&#x27;U&#x27;, &#x27;V&#x27;)</span><br></pre></td></tr></table></figure>

<p>消除了竞争产品中类似请求的面纱的主要问题，但这种实现的缺点是没有额外的参数传递给sys.dm_db_index_physical_stats可以限制扫描明显不必要的索引的函数。事实上，这会导致在扫描阶段获取系统中所有索引的信息以及不必要的磁盘负载。</p>
<p>值得一提的是，从中获取的数据sys.dm_db_index_physical_stats不会永久缓存在缓冲池中，因此在获取有关索引碎片的信息时最小化物理读取是我的应用程序开发过程中的优先任务之一。</p>
<p>经过多次实验，我设法通过将扫描分为两部分来结合这两种方法。最初，一个大请求通过过滤那些不包括在过滤范围内的分区来预先确定分区的大小：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO #AllocationUnits (ContainerID, ReservedPages, UsedPages)</span><br><span class="line">SELECT [container_id]</span><br><span class="line">     , SUM([total_pages])</span><br><span class="line">     , SUM([used_pages])</span><br><span class="line">FROM sys.allocation_units WITH(NOLOCK)</span><br><span class="line">GROUP BY [container_id]</span><br><span class="line">HAVING SUM([total_pages]) BETWEEN @MinIndexSize AND @MaxIndexSize</span><br></pre></td></tr></table></figure>
<p>接下来，我们只获取那些包含数据的分区，以避免对空索引进行不必要的读取。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT [object_id]</span><br><span class="line">     , [index_id]</span><br><span class="line">     , [partition_id]</span><br><span class="line">     , [partition_number]</span><br><span class="line">     , [rows]</span><br><span class="line">     , [data_compression]</span><br><span class="line">INTO #Partitions</span><br><span class="line">FROM sys.partitions WITH(NOLOCK)</span><br><span class="line">WHERE [object_id] &gt; 255</span><br><span class="line">    AND [rows] &gt; 0</span><br><span class="line">    AND [object_id] NOT IN (SELECT * FROM #ExcludeList)</span><br></pre></td></tr></table></figure>
<p>根据设置，仅获取用户想要分析的索引类型（支持使用堆、集群&#x2F;非集群索引和列存储）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO #Indexes</span><br><span class="line">SELECT ObjectID         = i.[object_id]</span><br><span class="line">     , IndexID          = i.index_id</span><br><span class="line">     , IndexName        = i.[name]</span><br><span class="line">     , PagesCount       = a.ReservedPages</span><br><span class="line">     , UnusedPagesCount = a.ReservedPages - a.UsedPages</span><br><span class="line">     , PartitionNumber  = p.[partition_number]</span><br><span class="line">     , RowsCount        = ISNULL(p.[rows], 0)</span><br><span class="line">     , IndexType        = i.[type]</span><br><span class="line">     , IsAllowPageLocks = i.[allow_page_locks]</span><br><span class="line">     , DataSpaceID      = i.[data_space_id]</span><br><span class="line">     , DataCompression  = p.[data_compression]</span><br><span class="line">     , IsUnique         = i.[is_unique]</span><br><span class="line">     , IsPK             = i.[is_primary_key]</span><br><span class="line">     , FillFactorValue  = i.[fill_factor]</span><br><span class="line">     , IsFiltered       = i.[has_filter]</span><br><span class="line">FROM #AllocationUnits a</span><br><span class="line">JOIN #Partitions p ON a.ContainerID = p.[partition_id]</span><br><span class="line">JOIN sys.indexes i WITH(NOLOCK) ON i.[object_id] = p.[object_id]</span><br><span class="line"></span><br><span class="line">                               AND p.[index_id] = i.[index_id]</span><br><span class="line">WHERE i.[type] IN (0, 1, 2, 5, 6)</span><br><span class="line">    AND i.[object_id] &gt; 255</span><br></pre></td></tr></table></figure>
<p>之后，我们添加了一点魔法，并且……对于所有小索引，我们通过重复调用函数sys.dm_db_index_physical_stats并完整指示所有参数来确定碎片级别。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO #Fragmentation (ObjectID, IndexID, PartitionNumber, Fragmentation)</span><br><span class="line">SELECT i.ObjectID</span><br><span class="line">     , i.IndexID</span><br><span class="line">     , i.PartitionNumber</span><br><span class="line">     , r.[avg_fragmentation_in_percent]</span><br><span class="line">FROM #Indexes i</span><br><span class="line">CROSS APPLY sys.dm_db_index_physical_stats_</span><br><span class="line">    (@DBID, i.ObjectID, i.IndexID, i.PartitionNumber, &#x27;LIMITED&#x27;) r</span><br><span class="line">WHERE i.PagesCount &lt;= @PreDescribeSize</span><br><span class="line">    AND r.[index_level] = 0</span><br><span class="line">    AND r.[alloc_unit_type_desc] = &#x27;IN_ROW_DATA&#x27;</span><br><span class="line">    AND i.IndexType IN (0, 1, 2)</span><br></pre></td></tr></table></figure>
<p>接下来，我们通过过滤掉多余的数据，将所有可能的信息返回给客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT i.ObjectID</span><br><span class="line">     , i.IndexID</span><br><span class="line">     , i.IndexName</span><br><span class="line">     , ObjectName       = o.[name]</span><br><span class="line">     , SchemaName       = s.[name]</span><br><span class="line">     , i.PagesCount</span><br><span class="line">     , i.UnusedPagesCount</span><br><span class="line">     , i.PartitionNumber</span><br><span class="line">     , i.RowsCount</span><br><span class="line">     , i.IndexType</span><br><span class="line">     , i.IsAllowPageLocks</span><br><span class="line">     , u.TotalWrites</span><br><span class="line">     , u.TotalReads</span><br><span class="line">     , u.TotalSeeks</span><br><span class="line">     , u.TotalScans</span><br><span class="line">     , u.TotalLookups</span><br><span class="line">     , u.LastUsage</span><br><span class="line">     , i.DataCompression</span><br><span class="line">     , f.Fragmentation</span><br><span class="line">     , IndexStats       = STATS_DATE(i.ObjectID, i.IndexID)</span><br><span class="line">     , IsLobLegacy      = ISNULL(lob.IsLobLegacy, 0)</span><br><span class="line">     , IsLob            = ISNULL(lob.IsLob, 0)</span><br><span class="line">     , IsSparse         = CAST(CASE WHEN p.ObjectID IS NULL THEN 0 ELSE 1 END AS BIT)</span><br><span class="line">     , IsPartitioned    = CAST(CASE WHEN dds.[data_space_id] _</span><br><span class="line">                          IS NOT NULL THEN 1 ELSE 0 END AS BIT)</span><br><span class="line">     , FileGroupName    = fg.[name]</span><br><span class="line">     , i.IsUnique</span><br><span class="line">     , i.IsPK</span><br><span class="line">     , i.FillFactorValue</span><br><span class="line">     , i.IsFiltered</span><br><span class="line">     , a.IndexColumns</span><br><span class="line">     , a.IncludedColumns</span><br><span class="line">FROM #Indexes i</span><br><span class="line">JOIN sys.objects o WITH(NOLOCK) ON o.[object_id] = i.ObjectID</span><br><span class="line">JOIN sys.schemas s WITH(NOLOCK) ON s.[schema_id] = o.[schema_id]</span><br><span class="line">LEFT JOIN #AggColumns a ON a.ObjectID = i.ObjectID</span><br><span class="line">                       AND a.IndexID = i.IndexID</span><br><span class="line">LEFT JOIN #Sparse p ON p.ObjectID = i.ObjectID</span><br><span class="line">LEFT JOIN #Fragmentation f ON f.ObjectID = i.ObjectID</span><br><span class="line">                          AND f.IndexID = i.IndexID</span><br><span class="line">                          AND f.PartitionNumber = i.PartitionNumber</span><br><span class="line">LEFT JOIN (</span><br><span class="line">    SELECT ObjectID      = [object_id]</span><br><span class="line">         , IndexID       = [index_id]</span><br><span class="line">         , TotalWrites   = NULLIF([user_updates], 0)</span><br><span class="line">         , TotalReads    = NULLIF([user_seeks] + [user_scans] + [user_lookups], 0)</span><br><span class="line">         , TotalSeeks    = NULLIF([user_seeks], 0)</span><br><span class="line">         , TotalScans    = NULLIF([user_scans], 0)</span><br><span class="line">         , TotalLookups  = NULLIF([user_lookups], 0)</span><br><span class="line">         , LastUsage     = (</span><br><span class="line">                                SELECT MAX(dt)</span><br><span class="line">                                FROM (</span><br><span class="line">                                    VALUES ([last_user_seek])</span><br><span class="line">                                         , ([last_user_scan])</span><br><span class="line">                                         , ([last_user_lookup])</span><br><span class="line">                                         , ([last_user_update])</span><br><span class="line">                                ) t(dt)</span><br><span class="line">                           )</span><br><span class="line">    FROM sys.dm_db_index_usage_stats WITH(NOLOCK)</span><br><span class="line">    WHERE [database_id] = @DBID</span><br><span class="line">) u ON i.ObjectID = u.ObjectID</span><br><span class="line">   AND i.IndexID = u.IndexID</span><br><span class="line">LEFT JOIN #Lob lob ON lob.ObjectID = i.ObjectID</span><br><span class="line">                  AND lob.IndexID = i.IndexID</span><br><span class="line">LEFT JOIN sys.destination_data_spaces dds WITH(NOLOCK) _</span><br><span class="line">            ON i.DataSpaceID = dds.[partition_scheme_id]</span><br><span class="line">            AND i.PartitionNumber = dds.[destination_id]</span><br><span class="line">JOIN sys.filegroups fg WITH(NOLOCK) _</span><br><span class="line">            ON ISNULL(dds.[data_space_id], i.DataSpaceID) = fg.[data_space_id]</span><br><span class="line">WHERE o.[type] IN (&#x27;V&#x27;, &#x27;U&#x27;)</span><br><span class="line">    AND (</span><br><span class="line">            f.Fragmentation &gt;= @Fragmentation</span><br><span class="line">        OR</span><br><span class="line">            i.PagesCount &gt; @PreDescribeSize</span><br><span class="line">        OR</span><br><span class="line">            i.IndexType IN (5, 6)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>之后，点请求确定大型索引的碎片级别。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXEC sp_executesql N&#x27;</span><br><span class="line">DECLARE @DBID INT = DB_ID()</span><br><span class="line">SELECT [avg_fragmentation_in_percent]</span><br><span class="line">FROM sys.dm_db_index_physical_stats(@DBID, @ObjectID, @IndexID, @PartitionNumber, &#x27;&#x27;LIMITED&#x27;&#x27;)</span><br><span class="line">WHERE [index_level] = 0</span><br><span class="line">    AND [alloc_unit_type_desc] = &#x27;&#x27;IN_ROW_DATA&#x27;&#x27;&#x27;</span><br><span class="line">    , N&#x27;@ObjectID int,@IndexID int,@PartitionNumber int&#x27;</span><br><span class="line">    , @ObjectId = 1044198770, @IndexId = 1, @PartitionNumber = 1</span><br><span class="line"></span><br><span class="line">EXEC sp_executesql N&#x27;</span><br><span class="line">DECLARE @DBID INT = DB_ID()</span><br><span class="line">SELECT [avg_fragmentation_in_percent]</span><br><span class="line">FROM sys.dm_db_index_physical_stats(@DBID, @ObjectID, @IndexID, @PartitionNumber, &#x27;&#x27;LIMITED&#x27;&#x27;)</span><br><span class="line">WHERE [index_level] = 0</span><br><span class="line">    AND [alloc_unit_type_desc] = &#x27;&#x27;IN_ROW_DATA&#x27;&#x27;&#x27;</span><br><span class="line">    , N&#x27;@ObjectID int,@IndexID int,@PartitionNumber int&#x27;</span><br><span class="line">    , @ObjectId = 1552724584, @IndexId = 0, @PartitionNumber = 1</span><br></pre></td></tr></table></figure>
<p>由于这种方法，在生成请求时，我设法解决了竞争对手应用程序中遇到的扫描性能问题。本来可以到此为止，但在开发的过程中，各种新的想法逐渐涌现，让我的产品应用范围的扩大成为可能。</p>
<p>最初，WAIT_AT_LOW_PRIORITY实现了对使用的支持，然后可以使用DATA_COMPRESSION和FILL_FACTOR重建索引。</p>
<p><img src="/pic/sql2022080203.png" alt="img"><br>该应用程序已经“散布”了以前计划外的功能，例如维护列存储：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM (</span><br><span class="line">    SELECT IndexID          = [index_id]</span><br><span class="line">         , PartitionNumber  = [partition_number]</span><br><span class="line">         , PagesCount       = SUM([size_in_bytes]) / 8192</span><br><span class="line">         , UnusedPagesCount = ISNULL(SUM(CASE WHEN [state] = 1 _</span><br><span class="line">                              THEN [size_in_bytes] END), 0) / 8192</span><br><span class="line">         , Fragmentation    = CAST(ISNULL(SUM(CASE WHEN [state] = 1 _</span><br><span class="line">                              THEN [size_in_bytes] END), 0)</span><br><span class="line">                            * 100. / SUM([size_in_bytes]) AS FLOAT)</span><br><span class="line">    FROM sys.fn_column_store_row_groups(@ObjectID)</span><br><span class="line">    GROUP BY [index_id]</span><br><span class="line">           , [partition_number]</span><br><span class="line">) t</span><br><span class="line">WHERE Fragmentation &gt;= @Fragmentation</span><br><span class="line">    AND PagesCount BETWEEN @MinIndexSize AND @MaxIndexSize</span><br></pre></td></tr></table></figure>

<p>或者基于以下信息创建非聚集索引的能力dm_db_missing_index：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ObjectID     = d.[object_id]</span><br><span class="line">     , UserImpact   = gs.[avg_user_impact]</span><br><span class="line">     , TotalReads   = gs.[user_seeks] + gs.[user_scans]</span><br><span class="line">     , TotalSeeks   = gs.[user_seeks]</span><br><span class="line">     , TotalScans   = gs.[user_scans]</span><br><span class="line">     , LastUsage    = ISNULL(gs.[last_user_scan], gs.[last_user_seek])</span><br><span class="line">     , IndexColumns =</span><br><span class="line">                CASE</span><br><span class="line">                    WHEN d.[equality_columns] IS NOT NULL </span><br><span class="line">                                _AND d.[inequality_columns] IS NOT NULL</span><br><span class="line">                        THEN d.[equality_columns] + &#x27;, &#x27; + d.[inequality_columns]</span><br><span class="line">                    WHEN d.[equality_columns] IS NOT NULL AND d.[inequality_columns] IS NULL</span><br><span class="line">                        THEN d.[equality_columns]</span><br><span class="line">                    ELSE d.[inequality_columns]</span><br><span class="line">                END</span><br><span class="line">     , IncludedColumns = d.[included_columns]</span><br><span class="line">FROM sys.dm_db_missing_index_groups g WITH(NOLOCK)</span><br><span class="line">JOIN sys.dm_db_missing_index_group_stats gs WITH(NOLOCK) _</span><br><span class="line">                       ON gs.[group_handle] = g.[index_group_handle]</span><br><span class="line">JOIN sys.dm_db_missing_index_details d WITH(NOLOCK) _</span><br><span class="line">                       ON g.[index_handle] = d.[index_handle]</span><br><span class="line">WHERE d.[database_id] = DB_ID()</span><br></pre></td></tr></table></figure>
<p>结果和计划<br>关键是开发计划并没有就此结束，因为我渴望进一步开发这个应用程序。下一步是添加用于查找重复 ( done ) 或未使用索引 ( done ) 的功能，以及在 SQL Server中实现对维护统计信息 ( done ) 的完全支持。</p>
<p>现在市场上有很多付费解决方案。我想相信，由于自由定位、更优化的查询以及对某人有用的各种 gismos 的可用性，该产品肯定会在日常任务中变得有用。</p>
<p>该应用程序的最新版本可以在GitHub 上下载。来源在同一个地方。</p>
<p>我期待任何反馈。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Sql</tag>
      </tags>
  </entry>
</search>
